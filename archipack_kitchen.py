# -*- coding:utf-8 -*-

# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

# <pep8 compliant>

# ----------------------------------------------------------
# Author: Stephen Leger (s-leger)
# Inspired by archimesh
# Automatic generation of kitchen cabinet
# Author: Antonio Vazquez (antonioya)
#
# ----------------------------------------------------------
# noinspection PyUnresolvedReferences
import bpy
# noinspection PyUnresolvedReferences
from bpy.types import Operator, PropertyGroup, Mesh, Panel
from bpy.props import (
    FloatProperty, IntProperty, BoolProperty,
    CollectionProperty, EnumProperty
)
from mathutils import Vector, Matrix
from math import pi, sin, cos
from .bmesh_utils import BmeshEdit as bmed
from .panel import Panel as Lofter
from .archipack_manipulator import Manipulable, archipack_manipulator
from .archipack_preset import ArchipackPreset, PresetMenuOperator
# from .archipack_gl import FeedbackPanel
from .archipack_object import ArchipackObject, ArchipackCreateTool
# from .archipack_keymaps import Keymaps


# ----------------------------------------------------------
#  Define rotation types
# ----------------------------------------------------------
RotationType_Default = 0
RotationType_R90CW = 1
RotationType_R90CCW = 2
RotationType_R180 = 3
RotationType_User = 4

# ----------------------------------------------------------
# Material index
# ----------------------------------------------------------
mat_inside = 0
mat_base = 1
mat_wall = 2
mat_full = 3
mat_border = 4
mat_counter = 5
mat_baseboard = 6
mat_handle = 7
mat_glass = 8
mat_metal = 9
mat_owen_handle = 10
mat_owen_inside = 11
mat_owen_metal = 9
mat_owen_glass = 8
mat_owen_panel = 12
mat_dishwasher_panel = 9
mat_dishwasher_face = 1
mat_dishwasher_handle = 12
mat_cooker_side = 9
mat_cooker_top = 12
mat_sink = 9
mat_range_body = 9
mat_range_filter = 12


def update(self, context):
    self.update(context)


def update_manipulators(self, context):
    self.update(context, manipulable_refresh=True)


def update_parent(self, context):
    self.update_parent(context)


def chanfer_square(x, y, z, r, sx, sy):
    """
        x, y, z of center
        sx, sy size
        r radius
        back
           x0 x1
        y0 2   3
        y1 1   4
        front
    """

    verts = []
    dx = sx - 2 * r
    dy = sy - 2 * r
    seg = 12
    q = int(1 + seg / 4)
    da = 2 * pi / seg
    xc = x + r - 0.5 * sx
    yc = y + r - 0.5 * sy
    a = 9 * da
    for j in range(2):
        for k in range(2):
            for n in range(q):
                verts.append((round(xc + r * cos(a), 3), round(yc + r * sin(a), 3), z))
                a -= da
            yc += dy
            a += da
        yc = y - r + 0.5 * sy
        dy = -dy
        xc += dx
    return verts


def make_box(tM, x0, x1, y0, y1, z0, z1, r, idmat, chanfer, verts, faces, matids, uvs):
    f = len(verts)
    if chanfer == 2 and r != 0:
        # Chanfer right front 
        s = 5
        dx, dy = x1 - x0, y1 - y0
        r = min(abs(r), abs(dx), abs(dy))
        ry = r
        if dy < 0:
            ry = -ry
        rx = r
        if dx < 0:
            rx = -rx
        y2 = y1 - ry
        x2 = x0 + rx
        x3 = x1 - rx
        verts.extend([tM * Vector((v)) for v in [
            (x1, y0, z0), (x1, y1, z0), (x2, y1, z0), (x0, y2, z0), (x0, y0, z0),
            (x1, y0, z1), (x1, y1, z1), (x2, y1, z1), (x0, y2, z1), (x0, y0, z1)
            ]])
        uvs.extend([[(0, 0), (1, 0), (1, 0.9), (0.9, 1),(0, 1)] for i in range(2)])
    elif chanfer and r != 0:
        s = 6
        dx, dy = x1 - x0, y1 - y0
        r = min(abs(r), 0.3 * abs(dx), 0.3 * abs(dy))
        ry = r
        if dy < 0:
            ry = -ry
        rx = r
        if dx < 0:
            rx = -rx
        y2 = y1 - ry
        x2 = x0 + rx
        x3 = x1 - rx
        verts.extend([tM * Vector((v)) for v in [
            (x1, y0, z0), (x1, y2, z0), (x3, y1, z0), (x2, y1, z0), (x0, y2, z0), (x0, y0, z0),
            (x1, y0, z1), (x1, y2, z1), (x3, y1, z1), (x2, y1, z1), (x0, y2, z1), (x0, y0, z1)
            ]])
        uvs.extend([[(0, 0), (1, 0), (1, 0.9), (0.9, 1), (0.1, 1), (0.1, 0.9)] for i in range(2)])
    else:
        s = 4
        verts.extend([tM * Vector((v)) for v in [
            (x0, y1, z0), (x0, y0, z0), (x1, y0, z0), (x1, y1, z0),
            (x0, y1, z1), (x0, y0, z1), (x1, y0, z1), (x1, y1, z1)
            ]])
        uvs.extend([[(0, 0), (1, 0), (1, 1), (0, 1)] for i in range(2)])
    # sides
    faces.extend([(f + i + 1, f + i, f + s + i, f + s + i + 1) for i in range(s - 1)])
    # back
    faces.append((f, f + s - 1, f + 2 * s - 1, f + s))
    # bottom
    faces.append(tuple([f + i for i in range(s)]))
    # top
    faces.append(tuple([f + 2 * s - 1 - i for i in range(s)]))
    matids.extend([idmat for i in range(s + 2)])
    uvs.extend([[(0, 0), (1, 0), (1, 1), (0, 1)] for i in range(s)])


def dishwasher_door(size, verts, faces, matids, uvs):
    f = len(verts)
    cm = size.x / 60
    # x from left = 0 to right
    x0 = 0
    x1 = x0 + 0.5 * size.x - 5 * cm
    x2 = x0 + 0.5 * size.x + 5 * cm
    x3 = size.x

    # y from inside = th to outside
    y0 = size.z - 0.1 * cm
    y1 = y0 - 0.1 * cm
    y2 = 0

    # z from bottom = 0 to top
    z0 = 0.5 * cm
    z4 = size.y
    z5 = z4 - 2 * cm
    z3 = z5 - 3.35 * cm
    z2 = z3 - 4 * cm
    z1 = z2 - 3.35 * cm
    verts.extend([Vector(v) for v in [
        (x0, y0, z5), (x0, y0, z1), (x3, y0, z1),
        (x3, y0, z5), (x2, y2, z3), (x2, y2, z2),
        (x1, y2, z2), (x1, y2, z3), (x3, y0, z4),
        (x0, y0, z4), (x0, y2, z4), (x3, y2, z4),
        (x0, y0, z0), (x0, y2, z0), (x3, y0, z0),
        (x3, y2, z0), (x3, y2, z1), (x0, y2, z1),
        (x3, y2, z5), (x0, y2, z5), (x2, y1, z2),
        (x1, y1, z2), (x2, y1, z3), (x1, y1, z3)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (19, 0, 1, 17), (16, 2, 3, 18), (11, 10, 19, 18),
        (9, 0, 19, 10), (17, 1, 12, 13), (3, 8, 11, 18),
        (10, 11, 8, 9), (0, 9, 8, 3, 2, 1), (4, 7, 23, 22),
        (15, 13, 12, 14), (1, 2, 14, 12), (2, 16, 15, 14),
        (16, 17, 13, 15), (5, 6, 17, 16), (4, 5, 16, 18),
        (7, 4, 18, 19), (6, 7, 19, 17), (20, 22, 23, 21),
        (6, 5, 20, 21), (7, 6, 21, 23), (5, 4, 22, 20)
        ]])
    matids.extend([
        mat_dishwasher_panel, mat_dishwasher_panel, mat_dishwasher_face,
        mat_dishwasher_face, mat_dishwasher_face, mat_dishwasher_face,
        mat_dishwasher_face, mat_dishwasher_panel, mat_dishwasher_panel,
        mat_dishwasher_handle, mat_dishwasher_panel, mat_dishwasher_face,
        mat_dishwasher_face, mat_dishwasher_panel, mat_dishwasher_panel,
        mat_dishwasher_panel, mat_dishwasher_panel, mat_dishwasher_panel,
        mat_dishwasher_panel, mat_dishwasher_panel, mat_dishwasher_panel
        ])
    uvs.extend([
        [(0.0, 0.97), (0.041, 0.97), (0.041, 0.811), (0.0, 0.811)],
        [(0.0, 0.811), (0.041, 0.811), (0.041, 0.97), (0.0, 0.97)],
        [(1.0, 1.0), (0.042, 1.0), (0.042, 0.97), (1.0, 0.97)],
        [(0.041, 1.0), (0.041, 0.97), (0.0, 0.97), (0.0, 1.0)],
        [(0.0, 0.811), (0.041, 0.811), (0.041, 0.811), (0.0, 0.811)],
        [(0.041, 0.97), (0.041, 1.0), (0.0, 1.0), (0.0, 0.97)],
        [(0.042, 0.0), (1.0, 0.0), (1.0, 0.039), (0.042, 0.039)],
        [(0.042, 0.97), (0.042, 1.0), (1.0, 1.0), (1.0, 0.97), (1.0, 0.811), (0.042, 0.811)],
        [(0.942, 0.914), (0.101, 0.914), (0.101, 0.914), (0.942, 0.914)],
        [(1.0, 0.0), (0.042, 0.0), (0.042, 0.039), (1.0, 0.039)],
        [(0.042, 0.811), (1.0, 0.811), (1.0, 0.811), (0.042, 0.811)],
        [(0.041, 0.811), (0.0, 0.811), (0.0, 0.811), (0.041, 0.811)],
        [(1.0, 0.811), (0.042, 0.811), (0.042, 0.811), (1.0, 0.811)],
        [(0.942, 0.866), (0.101, 0.866), (0.042, 0.811), (1.0, 0.811)],
        [(0.942, 0.914), (0.942, 0.866), (1.0, 0.811), (1.0, 0.97)],
        [(0.101, 0.914), (0.942, 0.914), (1.0, 0.97), (0.042, 0.97)],
        [(0.101, 0.866), (0.101, 0.914), (0.042, 0.97), (0.042, 0.811)],
        [(0.942, 0.866), (0.942, 0.914), (0.101, 0.914), (0.101, 0.866)],
        [(0.101, 0.866), (0.942, 0.866), (0.942, 0.866), (0.101, 0.866)],
        [(0.101, 0.914), (0.101, 0.866), (0.101, 0.866), (0.101, 0.914)],
        [(0.942, 0.866), (0.942, 0.914), (0.942, 0.914), (0.942, 0.866)]
        ])


def dishwasher_cab(tM, x, y, z, z0, th, dy, verts, faces, matids, uvs):
    f = len(verts)
    cm = x / 60
    # x from left to right
    x0 = th
    x1 = x0 + 4 * cm
    x3 = x - th
    x2 = x3 - 4 * cm
    # y from back to front
    y0 = -th
    y1 = y0 - 4 * cm
    y2 = -y
    # z from bottom to top
    z0 += th
    z3 = z0 + z - 2 * th
    z1 = z0 + 3 * cm
    z2 = z3 - 3 * cm

    verts.extend([tM * Vector(v) for v in [
        (x3, y2, z3), (x3, y2, z0), (x0, y2, z0),
        (x0, y2, z3), (x0, y0, z3), (x0, y0, z0),
        (x3, y0, z0), (x3, y0, z3), (x1, y2, z2),
        (x1, y2, z1), (x2, y2, z1), (x2, y2, z2),
        (x2, y1, z2), (x2, y1, z1), (x1, y1, z1),
        (x1, y1, z2)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (2, 3, 4, 5), (3, 0, 7, 4), (0, 1, 6, 7),
        (1, 2, 5, 6), (5, 4, 7, 6), (3, 2, 9, 8),
        (0, 3, 8, 11), (1, 0, 11, 10), (2, 1, 10, 9),
        (9, 10, 13, 14), (10, 11, 12, 13), (11, 8, 15, 12),
        (8, 9, 14, 15), (12, 15, 14, 13)
        ]])
    matids.extend([mat_metal for i in range(14)])
    uvs.extend([
        [(0.042, 0.04), (0.042, 1.0), (0.938, 1.0), (0.938, 0.04)],
        [(0.074, 0.04), (0.968, 0.04), (0.968, 0.889), (0.074, 0.889)],
        [(0.042, 1.0), (0.042, 0.04), (0.938, 0.04), (0.938, 1.0)],
        [(0.968, 0.04), (0.074, 0.04), (0.074, 0.889), (0.968, 0.889)],
        [(0.074, 0.04), (0.074, 1.0), (0.968, 1.0), (0.968, 0.04)],
        [(0.074, 1.0), (0.074, 0.04), (0.106, 0.101), (0.106, 0.758)],
        [(0.968, 1.0), (0.074, 1.0), (0.106, 0.758), (0.936, 0.758)],
        [(0.968, 0.04), (0.968, 1.0), (0.936, 0.758), (0.936, 0.101)],
        [(0.074, 0.04), (0.968, 0.04), (0.936, 0.101), (0.106, 0.101)],
        [(0.106, 0.04), (0.936, 0.04), (0.936, 0.796), (0.106, 0.796)],
        [(0.042, 0.101), (0.042, 0.758), (0.84, 0.758), (0.84, 0.101)],
        [(0.936, 0.04), (0.106, 0.04), (0.106, 0.796), (0.936, 0.796)],
        [(0.042, 0.758), (0.042, 0.101), (0.84, 0.101), (0.84, 0.758)],
        [(0.936, 0.758), (0.106, 0.758), (0.106, 0.101), (0.936, 0.101)]
        ])


def oven_door(size, verts, faces, matids, uvs):
    cm = size.x / 60
    # x from left = 0 to right
    x0 = 0
    x5 = size.x
    x1 = x0 + 6.5 * cm
    x2 = x1 + 3 * cm
    x4 = x5 - 6.5 * cm
    x3 = x4 - 3 * cm
    # y from inside = th to outside
    y0 = size.z - 0.1 * cm
    y1 = 0
    y2 = y1 - 2 * cm
    y3 = y2 - 1 * cm
    # z from bottom = 0 to top
    z0 = 0.5 * cm
    z1 = z0 + 6.5 * cm
    z5 = size.y - 12.7 * cm
    z4 = z5 - 2.75 * cm
    z3 = z4 - 1 * cm
    z2 = z5 - 6.5 * cm
    f = len(verts)
    verts.extend([Vector(v) for v in [
        (x5, y1, z5), (x5, y1, z0), (x0, y1, z0),
        (x0, y1, z5), (x0, y0, z5), (x0, y0, z0),
        (x5, y0, z0), (x5, y0, z5), (x0, y1, z2),
        (x0, y1, z1), (x5, y1, z1), (x5, y1, z2),
        (x5, y0, z2), (x5, y0, z1), (x0, y0, z1),
        (x0, y0, z2), (x2, y2, z3), (x3, y2, z3),
        (x2, y2, z4), (x3, y2, z4), (x1, y2, z3),
        (x1, y2, z4), (x1, y3, z4), (x1, y3, z3),
        (x4, y2, z4), (x4, y2, z3), (x4, y3, z3),
        (x4, y3, z4), (x3, y1, z4), (x3, y1, z3),
        (x2, y1, z3), (x2, y1, z4), (x1, y1, z4),
        (x1, y1, z3), (x4, y1, z3), (x4, y1, z4),
        (x1, y1, z2), (x4, y1, z2), (x1, y1, z1),
        (x4, y1, z1), (x4, y0, z2), (x1, y0, z2),
        (x4, y0, z1), (x1, y0, z1)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (3, 0, 7, 4), (1, 2, 5, 6), (7, 12, 40, 41, 15, 4),
        (10, 1, 6, 13), (0, 3, 8, 36, 37, 11), (0, 11, 12, 7),
        (2, 1, 10, 39, 38, 9), (39, 10, 13, 42), (10, 13, 12, 11),
        (36, 8, 15, 41), (8, 15, 14, 9), (8, 3, 4, 15),
        (37, 39, 10, 11), (2, 9, 14, 5), (5, 14, 43, 42, 13, 6),
        (40, 12, 13, 42), (17, 16, 18, 19), (27, 22, 23, 26),
        (27, 24, 19, 18, 21, 22), (20, 23, 22, 21), (24, 19, 28, 35),
        (24, 27, 26, 25), (18, 21, 32, 31), (16, 17, 25, 26, 23, 20),
        (16, 30, 31, 18), (21, 32, 33, 20), (20, 16, 30, 33),
        (17, 25, 34, 29), (19, 28, 29, 17), (25, 34, 35, 24),
        (15, 41, 43, 14), (41, 40, 42, 43), (8, 9, 38, 36),
        (36, 38, 39, 37), (11, 37, 40, 12), (37, 36, 41, 40),
        (9, 38, 43, 14), (38, 39, 42, 43)
        ]])
    matids.extend([
        mat_owen_metal, mat_owen_metal, mat_owen_metal,
        mat_owen_metal, mat_owen_metal, mat_owen_metal,
        mat_owen_metal, mat_owen_metal, mat_owen_glass,
        mat_owen_metal, mat_owen_glass, mat_owen_metal,
        mat_owen_glass, mat_owen_metal, mat_owen_metal,
        mat_owen_panel, mat_owen_metal, mat_owen_metal,
        mat_owen_metal, mat_owen_metal, mat_owen_handle,
        mat_owen_metal, mat_owen_handle, mat_owen_metal,
        mat_owen_handle, mat_owen_handle, mat_owen_handle,
        mat_owen_handle, mat_owen_handle, mat_owen_handle,
        mat_owen_panel, mat_owen_glass, mat_owen_glass,
        mat_owen_glass, mat_owen_metal, mat_owen_metal,
        mat_owen_metal, mat_owen_metal
        ])
    uvs.extend([
        [(0.054, 0.62), (0.451, 0.604), (0.453, 0.623), (0.056, 0.639)],
        [(0.451, 0.477), (0.056, 0.494), (0.054, 0.475), (0.451, 0.458)],
        [(0.453, 0.623), (0.507, 0.628), (0.452, 0.693), (0.067, 0.693), (0.001, 0.65), (0.056, 0.639)],
        [(0.509, 0.48), (0.451, 0.477), (0.451, 0.458), (0.502, 0.444)],
        [(0.451, 0.604), (0.054, 0.62), (0.0, 0.614), (0.055, 0.549), (0.44, 0.549), (0.506, 0.592)],
        [(0.451, 0.604), (0.506, 0.592), (0.507, 0.628), (0.453, 0.623)],
        [(0.056, 0.494), (0.451, 0.477), (0.509, 0.48), (0.453, 0.549), (0.067, 0.548), (0.001, 0.505)],
        [(0.444, 0.741), (0.498, 0.741), (0.498, 0.763), (0.444, 0.763)],
        [(0.604, 0.246), (0.609, 0.268), (1.0, 0.168), (0.863, 0.28)],
        [(0.054, 0.784), (0.0, 0.784), (0.0, 0.763), (0.054, 0.763)],
        [(0.243, 0.274), (0.243, 0.124), (0.0, 0.246), (0.073, 0.261)],
        [(0.0, 0.614), (0.054, 0.62), (0.056, 0.639), (0.001, 0.65)],
        [(0.702, 0.386), (0.593, 0.227), (0.604, 0.246), (0.863, 0.28)],
        [(0.056, 0.494), (0.001, 0.505), (0.0, 0.469), (0.054, 0.475)],
        [(0.054, 0.475), (0.0, 0.469), (0.055, 0.404), (0.44, 0.404), (0.502, 0.444), (0.451, 0.458)],
        [(0.793, 0.06), (1.0, 0.168), (0.609, 0.268), (0.603, 0.274)],
        [(0.753, 0.694), (0.045, 0.729), (0.045, 0.741), (0.754, 0.705)],
        [(0.8, 0.698), (0.0, 0.739), (0.002, 0.734), (0.798, 0.695)],
        [(0.8, 0.698), (0.79, 0.699), (0.754, 0.705), (0.045, 0.741), (0.011, 0.74), (0.0, 0.739)],
        [(0.012, 0.733), (0.002, 0.734), (0.0, 0.739), (0.011, 0.74)],
        [(0.79, 0.699), (0.754, 0.705), (0.757, 0.696), (0.786, 0.694)],
        [(0.79, 0.699), (0.8, 0.698), (0.798, 0.695), (0.789, 0.696)],
        [(0.045, 0.741), (0.011, 0.74), (0.019, 0.737), (0.037, 0.737)],
        [(0.045, 0.729), (0.753, 0.694), (0.789, 0.696), (0.798, 0.695), (0.002, 0.734), (0.012, 0.733)],
        [(0.045, 0.729), (0.037, 0.734), (0.037, 0.737), (0.045, 0.741)],
        [(0.011, 0.74), (0.019, 0.737), (0.019, 0.735), (0.012, 0.733)],
        [(0.012, 0.733), (0.045, 0.729), (0.037, 0.734), (0.019, 0.735)],
        [(0.753, 0.694), (0.789, 0.696), (0.786, 0.702), (0.757, 0.702)],
        [(0.754, 0.705), (0.757, 0.696), (0.757, 0.702), (0.753, 0.694)],
        [(0.789, 0.696), (0.786, 0.702), (0.786, 0.694), (0.79, 0.699)],
        [(0.243, 0.124), (0.295, 0.0), (0.172, 0.232), (0.0, 0.246)],
        [(0.295, 0.0), (0.793, 0.06), (0.603, 0.274), (0.172, 0.232)],
        [(0.243, 0.274), (0.073, 0.261), (0.191, 0.235), (0.283, 0.404)],
        [(0.283, 0.404), (0.191, 0.235), (0.593, 0.227), (0.702, 0.386)],
        [(0.498, 0.784), (0.444, 0.784), (0.444, 0.763), (0.498, 0.763)],
        [(0.444, 0.784), (0.054, 0.784), (0.054, 0.763), (0.444, 0.763)],
        [(0.0, 0.741), (0.054, 0.741), (0.054, 0.763), (0.0, 0.763)],
        [(0.054, 0.741), (0.444, 0.741), (0.444, 0.763), (0.054, 0.763)]
        ])


def oven_cab(tM, x, y, z, z0, th, dy, verts, faces, matids, uvs):
    f = len(verts)
    cm = x / 60
    # x from left to right
    x0 = 0
    x5 = x
    x1 = x0 + th
    x2 = x1 + 4 * cm
    x4 = x5 - th
    x3 = x4 - 4 * cm
    # y from back to front
    y0 = -th
    y1 = y0 - 4 * cm
    y2 = -y
    y3 = y2 - 0.003 * cm
    y4 = y2 - dy
    # z from bottom to top

    z5 = z0 + z
    z6 = z5 - th
    z0 += th
    z1 = z0 + 4 * cm
    z3 = z5 - 12.5 * cm
    z2 = z3 - 4 * cm - th
    z4 = z5 - 2 * cm
    verts.extend([tM * Vector(v) for v in [
        (x4, y2, z6), (x4, y2, z0), (x1, y2, z0),
        (x1, y2, z6), (x1, y0, z6), (x1, y0, z0),
        (x4, y0, z0), (x4, y0, z6), (x2, y2, z2),
        (x2, y2, z1), (x3, y2, z1), (x3, y2, z2),
        (x3, y1, z2), (x3, y1, z1), (x2, y1, z1),
        (x2, y1, z2), (x0, y3, z4), (x0, y3, z3),
        (x5, y3, z3), (x5, y3, z4), (x5, y4, z4),
        (x5, y4, z3), (x0, y4, z3), (x0, y4, z4),
        (x5, y3, z5), (x0, y3, z5), (x0, y4, z5),
        (x5, y4, z5)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (2, 3, 4, 5), (3, 0, 7, 4), (0, 1, 6, 7),
        (1, 2, 5, 6), (5, 4, 7, 6), (3, 2, 9, 8),
        (0, 3, 8, 11), (1, 0, 11, 10), (2, 1, 10, 9),
        (9, 10, 13, 14), (10, 11, 12, 13), (11, 8, 15, 12),
        (8, 9, 14, 15), (12, 15, 14, 13), (23, 16, 17, 22),
        (21, 18, 19, 20), (27, 26, 23, 20), (25, 16, 23, 26),
        (21, 22, 17, 18), (19, 24, 27, 20), (26, 27, 24, 25),
        (16, 25, 24, 19, 18, 17), (21, 20, 23, 22)
        ]])
    matids.extend([
        mat_owen_metal, mat_owen_metal, mat_owen_metal,
        mat_owen_metal, mat_owen_metal, mat_owen_inside,
        mat_owen_inside, mat_owen_inside, mat_owen_inside,
        mat_owen_inside, mat_owen_inside, mat_owen_inside,
        mat_owen_inside, mat_owen_inside, mat_owen_glass,
        mat_owen_glass, mat_owen_metal, mat_owen_metal,
        mat_owen_glass, mat_owen_metal, mat_owen_metal,
        mat_owen_panel, mat_owen_glass
        ])
    uvs.extend([
        [(0.042, 0.04), (0.042, 1.0), (0.938, 1.0), (0.938, 0.04)],
        [(0.074, 0.04), (0.968, 0.04), (0.968, 0.889), (0.074, 0.889)],
        [(0.042, 1.0), (0.042, 0.04), (0.938, 0.04), (0.938, 1.0)],
        [(0.968, 0.04), (0.074, 0.04), (0.074, 0.889), (0.968, 0.889)],
        [(0.074, 0.04), (0.074, 1.0), (0.968, 1.0), (0.968, 0.04)],
        [(0.074, 1.0), (0.074, 0.04), (0.106, 0.101), (0.106, 0.758)],
        [(0.968, 1.0), (0.074, 1.0), (0.106, 0.758), (0.936, 0.758)],
        [(0.968, 0.04), (0.968, 1.0), (0.936, 0.758), (0.936, 0.101)],
        [(0.074, 0.04), (0.968, 0.04), (0.936, 0.101), (0.106, 0.101)],
        [(0.106, 0.04), (0.936, 0.04), (0.936, 0.796), (0.106, 0.796)],
        [(0.042, 0.101), (0.042, 0.758), (0.84, 0.758), (0.84, 0.101)],
        [(0.936, 0.04), (0.106, 0.04), (0.106, 0.796), (0.936, 0.796)],
        [(0.042, 0.758), (0.042, 0.101), (0.84, 0.101), (0.84, 0.758)],
        [(0.936, 0.758), (0.106, 0.758), (0.106, 0.101), (0.936, 0.101)],
        [(0.0, 0.97), (0.041, 0.97), (0.041, 0.811), (0.0, 0.811)],
        [(0.0, 0.811), (0.041, 0.811), (0.041, 0.97), (0.0, 0.97)],
        [(1.0, 1.0), (0.042, 1.0), (0.042, 0.97), (1.0, 0.97)],
        [(0.041, 1.0), (0.041, 0.97), (0.0, 0.97), (0.0, 1.0)],
        [(1.0, 0.0), (0.042, 0.0), (0.042, 0.039), (1.0, 0.039)],
        [(0.041, 0.97), (0.041, 1.0), (0.0, 1.0), (0.0, 0.97)],
        [(0.042, 0.0), (1.0, 0.0), (1.0, 0.039), (0.042, 0.039)],
        [(0.042, 0.97), (0.042, 1.0), (1.0, 1.0), (1.0, 0.97), (1.0, 0.811), (0.042, 0.811)],
        [(1.0, 0.811), (1.0, 0.97), (0.042, 0.97), (0.042, 0.811)]
        ])


def sink(tM, x, y, z, r, sx, sy, verts, faces, matids, uvs):
    r2 = 2 * r + 0.002
    f = len(verts)
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y, z, r, sx + 0.02, sy + 0.02)])
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y, z + 0.002, r, sx + 0.02, sy + 0.02)])
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y, z + 0.002, r, sx - 0.004, sy - 0.004)])
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y, z - 0.2, r, sx - 0.02, sy - 0.02)])
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y + 0.35 * sy, z - 0.2, r, r2, r2)])
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y + 0.35 * sy, z - 0.25, r, r2, r2)])
    s = 16
    faces.extend([(
        f + j * s + i + 1,
        f + j * s + i,
        f + (j + 1) * s + i,
        f + (j + 1) * s + i + 1
        ) for i in range(s - 1) for j in range(5)])
    faces.extend([(
        f + j * s,
        f + (j + 1) * s - 1,
        f + (j + 2) * s - 1,
        f + (j + 1) * s
        ) for j in range(5)])
    matids.extend([mat_sink for i in range(s * 5)])


def cook_top(tM, x, y, z, r, sx, sy, verts, faces, matids, uvs):
    f = len(verts)
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y, z, r, sx + 0.02, sy + 0.02)])
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y, z + 0.002, r, sx + 0.02, sy + 0.02)])
    verts.extend([tM * Vector(v) for v in chanfer_square(x, y, z + 0.002, r, sx, sy)])
    s = 16
    faces.extend([(
        f + j * s + i + 1,
        f + j * s + i,
        f + (j + 1) * s + i,
        f + (j + 1) * s + i + 1
        ) for i in range(s - 1) for j in range(2)])
    faces.extend([(
        f + j * s,
        f + (j + 1) * s - 1,
        f + (j + 2) * s - 1,
        f + (j + 1) * s
        ) for j in range(2)])
    f += 2 * s
    faces.append(tuple([f + i for i in range(s)]))
    matids.extend([mat_cooker_side for i in range(s * 2)])
    matids.append(mat_cooker_top)


def rangehood(tM, x, y, z, z0, th, door_y, verts, faces, matids, uvs):
    cm = x / 60
    x0 = 0
    x1 = th
    x2 = 0.5 * (x - th)
    x3 = 0.5 * (x + th)
    x4 = x - th
    x5 = x
    
    y0 = 0
    y1 = -th
    y2 = -th - 10 * cm
    y4 = -y - 15 * cm
    y3 = y4 + th
    
    z1 = z0 + th
    z2 = z0 + z
    f = len(verts)
    verts.extend([tM * Vector(v) for v in [
        (x0, y0, z2), (x0, y4, z2), (x5, y0, z2),
        (x5, y4, z2), (x1, y1, z0), (x1, y3, z0),
        (x4, y3, z0), (x4, y1, z0), (x0, y0, z0),
        (x0, y4, z0), (x5, y4, z0), (x5, y0, z0),
        (x1, y1, z1), (x1, y3, z1), (x4, y3, z1),
        (x4, y1, z1), (x1, y2, z1), (x4, y2, z1),
        (x2, y3, z1), (x2, y2, z1), (x3, y3, z1),
        (x3, y2, z1)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (0, 1, 3, 2), (6, 5, 13, 18, 20, 14), (0, 2, 11, 8),
        (1, 0, 8, 9), (3, 1, 9, 10), (2, 3, 10, 11),
        (4, 5, 9, 8), (6, 7, 11, 10), (7, 4, 8, 11),
        (5, 6, 10, 9), (21, 17, 14, 20), (7, 6, 14, 17, 15),
        (4, 7, 15, 12), (5, 4, 12, 16, 13), (12, 15, 17, 21, 19, 16),
        (16, 19, 18, 13), (19, 21, 20, 18)
        ]])
    matids.extend([    
        mat_range_body, mat_range_body, mat_range_body,
        mat_range_body, mat_range_body, mat_range_body,
        mat_range_body, mat_range_body, mat_range_body,
        mat_range_body, mat_range_filter, mat_range_body,
        mat_range_body, mat_range_body, mat_range_body,
        mat_range_filter, mat_range_body
        ])
    uvs.extend([
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.5, 1.0), (0.933, 0.75), (0.933, 0.25), (0.5, 0.0), (0.067, 0.25), (0.067, 0.75)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)],
        [(0.5, 1.0), (0.933, 0.75), (0.933, 0.25), (0.5, 0.0), (0.067, 0.25), (0.067, 0.75)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        ])
    
    
def handle_01(tM, verts, faces, matids, uvs):
    # Horizontal
    f = len(verts)
    verts.extend([tM * Vector(v) for v in [
        (0.0591, -0.0251, 0.0038), (0.0601, -0.0273, 0.0029), (0.0607, -0.0288, 0.0016),
        (0.061, -0.0293, -0.0), (0.0607, -0.0288, -0.0016), (0.0601, -0.0273, -0.0029),
        (0.0591, -0.0251, -0.0038), (0.0579, -0.0225, -0.0041), (0.0567, -0.0199, -0.0038),
        (0.0557, -0.0177, -0.0029), (0.055, -0.0162, -0.0016), (0.0548, -0.0157, -0.0),
        (0.055, -0.0162, 0.0016), (0.0557, -0.0177, 0.0029), (0.0567, -0.0199, 0.0038),
        (0.0579, -0.0225, 0.0041), (0.0631, -0.0224, 0.0038), (0.0648, -0.0242, 0.0029),
        (0.066, -0.0253, 0.0016), (0.0664, -0.0257, -0.0), (0.066, -0.0253, -0.0016),
        (0.0648, -0.0242, -0.0029), (0.0631, -0.0224, -0.0038), (0.0611, -0.0204, -0.0041),
        (0.0591, -0.0184, -0.0038), (0.0574, -0.0166, -0.0029), (0.0563, -0.0155, -0.0016),
        (0.0559, -0.0151, -0.0), (0.0563, -0.0155, 0.0016), (0.0574, -0.0166, 0.0029),
        (0.0591, -0.0184, 0.0038), (0.0611, -0.0204, 0.0041), (0.0676, -0.0147, 0.0033),
        (0.07, -0.0148, 0.0025), (0.0717, -0.0148, 0.0014), (0.0722, -0.0149, -0.0),
        (0.0717, -0.0148, -0.0014), (0.07, -0.0148, -0.0025), (0.0676, -0.0147, -0.0033),
        (0.0647, -0.0146, -0.0035), (0.0619, -0.0145, -0.0033), (0.0595, -0.0144, -0.0025),
        (0.0578, -0.0143, -0.0014), (0.0573, -0.0143, -0.0), (0.0578, -0.0143, 0.0014),
        (0.0595, -0.0144, 0.0025), (0.0619, -0.0145, 0.0033), (0.0647, -0.0146, 0.0035),
        (0.0676, 0.0, 0.0033), (0.07, 0.0, 0.0025), (0.0717, 0.0, 0.0014),
        (0.0722, 0.0, -0.0), (0.0717, 0.0, -0.0014), (0.07, 0.0, -0.0025),
        (0.0676, 0.0, -0.0033), (0.0647, 0.0, -0.0035), (0.0619, 0.0, -0.0033),
        (0.0595, 0.0, -0.0025), (0.0578, 0.0, -0.0014), (0.0573, 0.0, -0.0),
        (0.0578, 0.0, 0.0014), (0.0595, 0.0, 0.0025), (0.0619, 0.0, 0.0033),
        (0.0647, 0.0, 0.0035), (-0.0591, -0.0251, 0.0038), (-0.0601, -0.0273, 0.0029),
        (-0.0607, -0.0288, 0.0016), (-0.061, -0.0293, -0.0), (-0.0607, -0.0288, -0.0016),
        (-0.0601, -0.0273, -0.0029), (-0.0591, -0.0251, -0.0038), (-0.0579, -0.0225, -0.0041),
        (-0.0567, -0.0199, -0.0038), (-0.0557, -0.0177, -0.0029), (-0.055, -0.0162, -0.0016),
        (-0.0548, -0.0157, -0.0), (-0.055, -0.0162, 0.0016), (-0.0557, -0.0177, 0.0029),
        (-0.0567, -0.0199, 0.0038), (-0.0579, -0.0225, 0.0041), (0.0, -0.0225, 0.0041),
        (0.0, -0.0196, 0.0038), (0.0, -0.0172, 0.0029), (0.0, -0.0156, 0.0016),
        (0.0, -0.015, -0.0), (0.0, -0.0156, -0.0016), (0.0, -0.0172, -0.0029),
        (0.0, -0.0196, -0.0038), (0.0, -0.0225, -0.0041), (0.0, -0.0254, -0.0038),
        (0.0, -0.0278, -0.0029), (0.0, -0.0294, -0.0016), (0.0, -0.03, -0.0),
        (0.0, -0.0294, 0.0016), (0.0, -0.0278, 0.0029), (0.0, -0.0254, 0.0038),
        (-0.0631, -0.0224, 0.0038), (-0.0648, -0.0242, 0.0029), (-0.066, -0.0253, 0.0016),
        (-0.0664, -0.0257, -0.0), (-0.066, -0.0253, -0.0016), (-0.0648, -0.0242, -0.0029),
        (-0.0631, -0.0224, -0.0038), (-0.0611, -0.0204, -0.0041), (-0.0591, -0.0184, -0.0038),
        (-0.0574, -0.0166, -0.0029), (-0.0563, -0.0155, -0.0016), (-0.0559, -0.0151, -0.0),
        (-0.0563, -0.0155, 0.0016), (-0.0574, -0.0166, 0.0029), (-0.0591, -0.0184, 0.0038),
        (-0.0611, -0.0204, 0.0041), (-0.0676, -0.0147, 0.0033), (-0.07, -0.0148, 0.0025),
        (-0.0717, -0.0148, 0.0014), (-0.0722, -0.0149, -0.0), (-0.0717, -0.0148, -0.0014),
        (-0.07, -0.0148, -0.0025), (-0.0676, -0.0147, -0.0033), (-0.0647, -0.0146, -0.0035),
        (-0.0619, -0.0145, -0.0033), (-0.0595, -0.0144, -0.0025), (-0.0578, -0.0143, -0.0014),
        (-0.0573, -0.0143, -0.0), (-0.0578, -0.0143, 0.0014), (-0.0595, -0.0144, 0.0025),
        (-0.0619, -0.0145, 0.0033), (-0.0647, -0.0146, 0.0035), (-0.0676, 0.0, 0.0033),
        (-0.07, 0.0, 0.0025), (-0.0717, 0.0, 0.0014), (-0.0722, 0.0, -0.0),
        (-0.0717, 0.0, -0.0014), (-0.07, 0.0, -0.0025), (-0.0676, 0.0, -0.0033),
        (-0.0647, 0.0, -0.0035), (-0.0619, 0.0, -0.0033), (-0.0595, 0.0, -0.0025),
        (-0.0578, 0.0, -0.0014), (-0.0573, 0.0, -0.0), (-0.0578, 0.0, 0.0014),
        (-0.0595, 0.0, 0.0025), (-0.0619, 0.0, 0.0033), (-0.0647, 0.0, 0.0035)]])

    faces.extend([tuple([f + i for i in v]) for v in [
        (90, 89, 6, 5), (88, 87, 8, 7), (86, 85, 10, 9), (84, 83, 12, 11), (80, 95, 0, 15),
        (82, 81, 14, 13), (93, 92, 3, 2), (91, 90, 5, 4), (89, 88, 7, 6), (87, 86, 9, 8),
        (85, 84, 11, 10), (95, 94, 1, 0), (83, 82, 13, 12), (94, 93, 2, 1), (81, 80, 15, 14),
        (92, 91, 4, 3), (2, 3, 19, 18), (13, 14, 30, 29), (15, 0, 16, 31), (11, 12, 28, 27),
        (9, 10, 26, 25), (7, 8, 24, 23), (5, 6, 22, 21), (3, 4, 20, 19), (14, 15, 31, 30),
        (1, 2, 18, 17), (12, 13, 29, 28), (0, 1, 17, 16), (10, 11, 27, 26), (8, 9, 25, 24),
        (6, 7, 23, 22), (4, 5, 21, 20), (19, 20, 36, 35), (30, 31, 47, 46), (17, 18, 34, 33),
        (28, 29, 45, 44), (16, 17, 33, 32), (26, 27, 43, 42), (24, 25, 41, 40), (22, 23, 39, 38),
        (20, 21, 37, 36), (18, 19, 35, 34), (29, 30, 46, 45), (31, 16, 32, 47), (27, 28, 44, 43),
        (25, 26, 42, 41), (23, 24, 40, 39), (21, 22, 38, 37), (36, 37, 53, 52), (34, 35, 51, 50),
        (45, 46, 62, 61), (47, 32, 48, 63), (43, 44, 60, 59), (41, 42, 58, 57), (39, 40, 56, 55),
        (37, 38, 54, 53), (35, 36, 52, 51), (46, 47, 63, 62), (33, 34, 50, 49), (44, 45, 61, 60),
        (32, 33, 49, 48), (42, 43, 59, 58), (40, 41, 57, 56), (38, 39, 55, 54), (90, 69, 70, 89),
        (88, 71, 72, 87), (86, 73, 74, 85), (84, 75, 76, 83), (80, 79, 64, 95), (82, 77, 78, 81),
        (93, 66, 67, 92), (91, 68, 69, 90), (89, 70, 71, 88), (87, 72, 73, 86), (85, 74, 75, 84),
        (95, 64, 65, 94), (83, 76, 77, 82), (94, 65, 66, 93), (81, 78, 79, 80), (92, 67, 68, 91),
        (66, 98, 99, 67), (77, 109, 110, 78), (79, 111, 96, 64), (75, 107, 108, 76), (73, 105, 106, 74),
        (71, 103, 104, 72), (69, 101, 102, 70), (67, 99, 100, 68), (78, 110, 111, 79), (65, 97, 98, 66),
        (76, 108, 109, 77), (64, 96, 97, 65), (74, 106, 107, 75), (72, 104, 105, 73), (70, 102, 103, 71),
        (68, 100, 101, 69), (99, 115, 116, 100), (110, 126, 127, 111), (97, 113, 114, 98), (108, 124, 125, 109),
        (96, 112, 113, 97), (106, 122, 123, 107), (104, 120, 121, 105), (102, 118, 119, 103),
        (100, 116, 117, 101),
        (98, 114, 115, 99), (109, 125, 126, 110), (111, 127, 112, 96), (107, 123, 124, 108),
        (105, 121, 122, 106),
        (103, 119, 120, 104), (101, 117, 118, 102), (116, 132, 133, 117), (114, 130, 131, 115),
        (125, 141, 142, 126),
        (127, 143, 128, 112), (123, 139, 140, 124), (121, 137, 138, 122), (119, 135, 136, 120),
        (117, 133, 134, 118),
        (115, 131, 132, 116), (126, 142, 143, 127), (113, 129, 130, 114), (124, 140, 141, 125),
        (112, 128, 129, 113),
        (122, 138, 139, 123), (120, 136, 137, 121), (118, 134, 135, 119)]])
    matids.extend([mat_handle for i in range(128)])
    uvs.extend([
        [(0.491, 0.089), (0.491, 0.087), (0.929, 0.026), (0.933, 0.025)],
        [(0.49, 0.083), (0.489, 0.078), (0.921, 0.024), (0.924, 0.026)],
        [(0.489, 0.076), (0.489, 0.077), (0.916, 0.021), (0.918, 0.022)],
        [(0.49, 0.081), (0.49, 0.085), (0.916, 0.021), (0.916, 0.021)],
        [(0.489, 0.079), (0.489, 0.074), (0.927, 0.012), (0.923, 0.014)],
        [(0.491, 0.086), (0.49, 0.083), (0.92, 0.017), (0.918, 0.019)],
        [(0.489, 0.075), (0.49, 0.081), (0.936, 0.018), (0.934, 0.014)],
        [(0.491, 0.086), (0.491, 0.089), (0.933, 0.025), (0.935, 0.022)],
        [(0.491, 0.087), (0.49, 0.083), (0.924, 0.026), (0.929, 0.026)],
        [(0.489, 0.078), (0.489, 0.076), (0.918, 0.022), (0.921, 0.024)],
        [(0.489, 0.077), (0.49, 0.081), (0.916, 0.021), (0.916, 0.021)],
        [(0.489, 0.074), (0.489, 0.073), (0.931, 0.012), (0.927, 0.012)],
        [(0.49, 0.085), (0.491, 0.086), (0.918, 0.019), (0.916, 0.021)],
        [(0.489, 0.073), (0.489, 0.075), (0.934, 0.014), (0.931, 0.012)],
        [(0.49, 0.083), (0.489, 0.079), (0.923, 0.014), (0.92, 0.017)],
        [(0.49, 0.081), (0.491, 0.086), (0.935, 0.022), (0.936, 0.018)],
        [(0.934, 0.014), (0.936, 0.018), (0.93, 0.019), (0.93, 0.018)],
        [(0.918, 0.019), (0.92, 0.017), (0.923, 0.018), (0.921, 0.02)],
        [(0.923, 0.014), (0.927, 0.012), (0.928, 0.016), (0.926, 0.017)],
        [(0.916, 0.021), (0.916, 0.021), (0.919, 0.02), (0.919, 0.02)],
        [(0.918, 0.022), (0.916, 0.021), (0.919, 0.02), (0.921, 0.021)],
        [(0.924, 0.026), (0.921, 0.024), (0.924, 0.022), (0.927, 0.022)],
        [(0.933, 0.025), (0.929, 0.026), (0.929, 0.022), (0.93, 0.021)],
        [(0.936, 0.018), (0.935, 0.022), (0.93, 0.02), (0.93, 0.019)],
        [(0.92, 0.017), (0.923, 0.014), (0.926, 0.017), (0.923, 0.018)],
        [(0.931, 0.012), (0.934, 0.014), (0.93, 0.018), (0.929, 0.017)],
        [(0.916, 0.021), (0.918, 0.019), (0.921, 0.02), (0.919, 0.02)],
        [(0.927, 0.012), (0.931, 0.012), (0.929, 0.017), (0.928, 0.016)],
        [(0.916, 0.021), (0.916, 0.021), (0.919, 0.02), (0.919, 0.02)],
        [(0.921, 0.024), (0.918, 0.022), (0.921, 0.021), (0.924, 0.022)],
        [(0.929, 0.026), (0.924, 0.026), (0.927, 0.022), (0.929, 0.022)],
        [(0.935, 0.022), (0.933, 0.025), (0.93, 0.021), (0.93, 0.02)],
        [(0.93, 0.019), (0.93, 0.02), (0.939, 0.018), (0.939, 0.018)],
        [(0.923, 0.018), (0.926, 0.017), (0.933, 0.019), (0.929, 0.021)],
        [(0.929, 0.017), (0.93, 0.018), (0.939, 0.017), (0.938, 0.017)],
        [(0.919, 0.02), (0.921, 0.02), (0.925, 0.021), (0.922, 0.021)],
        [(0.928, 0.016), (0.929, 0.017), (0.938, 0.017), (0.936, 0.018)],
        [(0.919, 0.02), (0.919, 0.02), (0.921, 0.02), (0.922, 0.019)],
        [(0.924, 0.022), (0.921, 0.021), (0.925, 0.018), (0.929, 0.018)],
        [(0.929, 0.022), (0.927, 0.022), (0.932, 0.018), (0.936, 0.018)],
        [(0.93, 0.02), (0.93, 0.021), (0.938, 0.019), (0.939, 0.018)],
        [(0.93, 0.018), (0.93, 0.019), (0.939, 0.018), (0.939, 0.017)],
        [(0.921, 0.02), (0.923, 0.018), (0.929, 0.021), (0.925, 0.021)],
        [(0.926, 0.017), (0.928, 0.016), (0.936, 0.018), (0.933, 0.019)],
        [(0.919, 0.02), (0.919, 0.02), (0.922, 0.021), (0.921, 0.02)],
        [(0.921, 0.021), (0.919, 0.02), (0.922, 0.019), (0.925, 0.018)],
        [(0.927, 0.022), (0.924, 0.022), (0.929, 0.018), (0.932, 0.018)],
        [(0.93, 0.021), (0.929, 0.022), (0.936, 0.018), (0.938, 0.019)],
        [(0.939, 0.018), (0.938, 0.019), (0.977, 0.002), (0.988, 0.005)],
        [(0.939, 0.017), (0.939, 0.018), (1.0, 0.009), (0.99, 0.016)],
        [(0.925, 0.021), (0.929, 0.021), (0.951, 0.03), (0.945, 0.027)],
        [(0.933, 0.019), (0.936, 0.018), (0.969, 0.027), (0.959, 0.03)],
        [(0.921, 0.02), (0.922, 0.021), (0.942, 0.023), (0.94, 0.017)],
        [(0.925, 0.018), (0.922, 0.019), (0.94, 0.012), (0.943, 0.007)],
        [(0.932, 0.018), (0.929, 0.018), (0.947, 0.003), (0.955, 0.0)],
        [(0.938, 0.019), (0.936, 0.018), (0.965, 0.0), (0.977, 0.002)],
        [(0.939, 0.018), (0.939, 0.018), (0.988, 0.005), (1.0, 0.009)],
        [(0.929, 0.021), (0.933, 0.019), (0.959, 0.03), (0.951, 0.03)],
        [(0.938, 0.017), (0.939, 0.017), (0.99, 0.016), (0.979, 0.022)],
        [(0.922, 0.021), (0.925, 0.021), (0.945, 0.027), (0.942, 0.023)],
        [(0.936, 0.018), (0.938, 0.017), (0.979, 0.022), (0.969, 0.027)],
        [(0.922, 0.019), (0.921, 0.02), (0.94, 0.017), (0.94, 0.012)],
        [(0.929, 0.018), (0.925, 0.018), (0.943, 0.007), (0.947, 0.003)],
        [(0.936, 0.018), (0.932, 0.018), (0.955, 0.0), (0.965, 0.0)],
        [(0.491, 0.089), (0.049, 0.15), (0.054, 0.15), (0.491, 0.087)],
        [(0.49, 0.083), (0.057, 0.148), (0.061, 0.145), (0.489, 0.078)],
        [(0.489, 0.076), (0.062, 0.143), (0.063, 0.141), (0.489, 0.077)],
        [(0.49, 0.081), (0.064, 0.141), (0.063, 0.141), (0.49, 0.085)],
        [(0.489, 0.079), (0.056, 0.136), (0.051, 0.135), (0.489, 0.074)],
        [(0.491, 0.086), (0.062, 0.139), (0.059, 0.137), (0.49, 0.083)],
        [(0.489, 0.075), (0.045, 0.139), (0.045, 0.143), (0.49, 0.081)],
        [(0.491, 0.086), (0.047, 0.147), (0.049, 0.15), (0.491, 0.089)],
        [(0.491, 0.087), (0.054, 0.15), (0.057, 0.148), (0.49, 0.083)],
        [(0.489, 0.078), (0.061, 0.145), (0.062, 0.143), (0.489, 0.076)],
        [(0.489, 0.077), (0.063, 0.141), (0.064, 0.141), (0.49, 0.081)],
        [(0.489, 0.074), (0.051, 0.135), (0.048, 0.136), (0.489, 0.073)],
        [(0.49, 0.085), (0.063, 0.141), (0.062, 0.139), (0.491, 0.086)],
        [(0.489, 0.073), (0.048, 0.136), (0.045, 0.139), (0.489, 0.075)],
        [(0.49, 0.083), (0.059, 0.137), (0.056, 0.136), (0.489, 0.079)],
        [(0.49, 0.081), (0.045, 0.143), (0.047, 0.147), (0.491, 0.086)],
        [(0.045, 0.139), (0.051, 0.141), (0.051, 0.143), (0.045, 0.143)],
        [(0.062, 0.139), (0.059, 0.14), (0.056, 0.139), (0.059, 0.137)],
        [(0.056, 0.136), (0.054, 0.139), (0.052, 0.139), (0.051, 0.135)],
        [(0.064, 0.141), (0.061, 0.141), (0.06, 0.141), (0.063, 0.141)],
        [(0.062, 0.143), (0.059, 0.143), (0.06, 0.142), (0.063, 0.141)],
        [(0.057, 0.148), (0.055, 0.146), (0.057, 0.144), (0.061, 0.145)],
        [(0.049, 0.15), (0.051, 0.145), (0.053, 0.146), (0.054, 0.15)],
        [(0.045, 0.143), (0.051, 0.143), (0.051, 0.144), (0.047, 0.147)],
        [(0.059, 0.137), (0.056, 0.139), (0.054, 0.139), (0.056, 0.136)],
        [(0.048, 0.136), (0.051, 0.14), (0.051, 0.141), (0.045, 0.139)],
        [(0.063, 0.141), (0.06, 0.141), (0.059, 0.14), (0.062, 0.139)],
        [(0.051, 0.135), (0.052, 0.139), (0.051, 0.14), (0.048, 0.136)],
        [(0.063, 0.141), (0.06, 0.142), (0.061, 0.141), (0.064, 0.141)],
        [(0.061, 0.145), (0.057, 0.144), (0.059, 0.143), (0.062, 0.143)],
        [(0.054, 0.15), (0.053, 0.146), (0.055, 0.146), (0.057, 0.148)],
        [(0.047, 0.147), (0.051, 0.144), (0.051, 0.145), (0.049, 0.15)],
        [(0.051, 0.143), (0.044, 0.143), (0.045, 0.145), (0.051, 0.144)],
        [(0.056, 0.139), (0.051, 0.142), (0.048, 0.142), (0.054, 0.139)],
        [(0.051, 0.14), (0.045, 0.141), (0.044, 0.142), (0.051, 0.141)],
        [(0.06, 0.141), (0.057, 0.142), (0.054, 0.142), (0.059, 0.14)],
        [(0.052, 0.139), (0.046, 0.141), (0.045, 0.141), (0.051, 0.14)],
        [(0.06, 0.142), (0.057, 0.141), (0.058, 0.142), (0.061, 0.141)],
        [(0.057, 0.144), (0.051, 0.143), (0.054, 0.142), (0.059, 0.143)],
        [(0.053, 0.146), (0.047, 0.145), (0.049, 0.144), (0.055, 0.146)],
        [(0.051, 0.144), (0.045, 0.145), (0.046, 0.145), (0.051, 0.145)],
        [(0.051, 0.141), (0.044, 0.142), (0.044, 0.143), (0.051, 0.143)],
        [(0.059, 0.14), (0.054, 0.142), (0.051, 0.142), (0.056, 0.139)],
        [(0.054, 0.139), (0.048, 0.142), (0.046, 0.141), (0.052, 0.139)],
        [(0.061, 0.141), (0.058, 0.142), (0.057, 0.142), (0.06, 0.141)],
        [(0.059, 0.143), (0.054, 0.142), (0.057, 0.141), (0.06, 0.142)],
        [(0.055, 0.146), (0.049, 0.144), (0.051, 0.143), (0.057, 0.144)],
        [(0.051, 0.145), (0.046, 0.145), (0.047, 0.145), (0.053, 0.146)],
        [(0.045, 0.145), (0.007, 0.151), (0.014, 0.151), (0.046, 0.145)],
        [(0.044, 0.142), (0.007, 0.147), (0.0, 0.15), (0.044, 0.143)],
        [(0.054, 0.142), (0.027, 0.146), (0.025, 0.145), (0.051, 0.142)],
        [(0.048, 0.142), (0.022, 0.145), (0.018, 0.145), (0.046, 0.141)],
        [(0.058, 0.142), (0.027, 0.146), (0.027, 0.146), (0.057, 0.142)],
        [(0.054, 0.142), (0.027, 0.146), (0.027, 0.146), (0.057, 0.141)],
        [(0.049, 0.144), (0.023, 0.148), (0.025, 0.147), (0.051, 0.143)],
        [(0.046, 0.145), (0.014, 0.151), (0.019, 0.15), (0.047, 0.145)],
        [(0.044, 0.143), (0.0, 0.15), (0.007, 0.151), (0.045, 0.145)],
        [(0.051, 0.142), (0.025, 0.145), (0.022, 0.145), (0.048, 0.142)],
        [(0.045, 0.141), (0.013, 0.145), (0.007, 0.147), (0.044, 0.142)],
        [(0.057, 0.142), (0.027, 0.146), (0.027, 0.146), (0.054, 0.142)],
        [(0.046, 0.141), (0.018, 0.145), (0.013, 0.145), (0.045, 0.141)],
        [(0.057, 0.141), (0.027, 0.146), (0.027, 0.146), (0.058, 0.142)],
        [(0.051, 0.143), (0.025, 0.147), (0.027, 0.146), (0.054, 0.142)],
        [(0.047, 0.145), (0.019, 0.15), (0.023, 0.148), (0.049, 0.144)]
        ])


def handle_02(tM, verts, faces, matids, uvs):
    f = len(verts)
    verts.extend([tM * Vector(v) for v in [
        (0.091, 0.0, 0.002), (0.091, 0.0, -0.002), (0.091, -0.024, -0.002),
        (0.091, -0.027, 0.002), (0.091, -0.024, -0.016), (0.091, -0.027, -0.018),
        (0.091, -0.021, -0.016), (0.091, -0.021, -0.018), (-0.091, 0.0, 0.002),
        (-0.091, 0.0, -0.002), (-0.091, -0.024, -0.002), (-0.091, -0.027, 0.002),
        (-0.091, -0.024, -0.016), (-0.091, -0.027, -0.018), (-0.091, -0.021, -0.016),
        (-0.091, -0.021, -0.018)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (7, 15, 14, 6), (9, 8, 0, 1), (10, 9, 1, 2),
        (12, 10, 2, 4), (3, 5, 7, 6, 4, 2, 1, 0), (14, 12, 4, 6),
        (15, 7, 5, 13), (3, 11, 13, 5), (8, 11, 3, 0),
        (11, 8, 9, 10, 12, 14, 15, 13)
        ]])
    matids.extend([mat_handle for i in range(10)])
    uvs.extend([
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.5, 1.0), (0.854, 0.854), (1.0, 0.5), (0.854, 0.146),
        (0.5, 0.0), (0.146, 0.146), (0.0, 0.5), (0.146, 0.854)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.5, 1.0), (0.854, 0.854), (1.0, 0.5), (0.854, 0.146),
        (0.5, 0.0), (0.146, 0.146), (0.0, 0.5), (0.146, 0.854)]
    ])


def handle_03(tM, verts, faces, matids, uvs):
    # round
    segs = 16
    profile = Lofter(
        False,  # closed
        [0, 0, 1, 1],  # x index
        [0, -0.02],
        [0, -0.02, -0.02, -0.025],
        [mat_handle, mat_handle, mat_handle, mat_metal],  # materials
        side_cap_front=0,
        side_cap_back=3      # cap index
        )
    offset = Vector((0, 0, 0))
    center = Vector((0, 0.025, 0))
    origin = Vector((0, 0.025, 0))
    size = Vector((0.05, 0.05, 0))
    radius = Vector((0.005, 0, 0))
    f = len(verts)
    verts.extend([tM * Vector(v) for v in profile.vertices(segs, offset, center, origin, size,
        radius, 0, 0, shape_z=None, path_type='CIRCLE')])
    faces.extend([tuple([f + i for i in v]) for v in profile.faces(segs, path_type='CIRCLE')])
    uvs.extend(profile.uv(segs, center, origin, size,
        radius, 0, 0, 0, 0, path_type='CIRCLE'))
    matids.extend(profile.mat(segs, mat_handle, mat_handle, path_type='CIRCLE'))


def handle_04(tM, verts, faces, matids, uvs):
    f = len(verts)
    verts.extend([tM * Vector(v) for v in [
        (0.109, -0.018, 0.004), (0.109, -0.016, 0.004), (0.109, -0.015, 0.003),
        (0.109, -0.014, 0.002), (0.109, -0.014, -0.0), (0.109, -0.014, -0.002),
        (0.109, -0.015, -0.003), (0.109, -0.016, -0.004), (0.109, -0.018, -0.004),
        (0.109, -0.019, -0.004), (0.109, -0.02, -0.003), (0.109, -0.021, -0.002),
        (0.109, -0.022, 0.0), (0.109, -0.021, 0.002), (0.109, -0.02, 0.003),
        (0.109, -0.019, 0.004), (0.08, -0.014, 0.001), (0.079, -0.014, 0.001),
        (0.079, -0.014, 0.001), (0.078, -0.014, 0.001), (0.078, -0.014, -0.0),
        (0.078, -0.014, -0.001), (0.079, -0.014, -0.001), (0.079, -0.014, -0.001),
        (0.08, -0.014, -0.001), (0.08, -0.014, -0.001), (0.081, -0.014, -0.001),
        (0.081, -0.014, -0.001), (0.081, -0.014, 0.0), (0.081, -0.014, 0.001),
        (0.081, -0.014, 0.001), (0.08, -0.014, 0.001), (0.08, 0.0, 0.001),
        (0.079, 0.0, 0.001), (0.079, 0.0, 0.001), (0.078, 0.0, 0.001),
        (0.078, 0.0, -0.0), (0.078, 0.0, -0.001), (0.079, 0.0, -0.001),
        (0.079, 0.0, -0.001), (0.08, 0.0, -0.001), (0.08, 0.0, -0.001),
        (0.081, 0.0, -0.001), (0.081, 0.0, -0.001), (0.081, 0.0, 0.0),
        (0.081, 0.0, 0.001), (0.081, 0.0, 0.001), (0.08, 0.0, 0.001),
        (-0.109, -0.018, 0.004), (-0.109, -0.016, 0.004), (-0.109, -0.015, 0.003),
        (-0.109, -0.014, 0.002), (-0.109, -0.014, -0.0), (-0.109, -0.014, -0.002),
        (-0.109, -0.015, -0.003), (-0.109, -0.016, -0.004), (-0.109, -0.018, -0.004),
        (-0.109, -0.019, -0.004), (-0.109, -0.02, -0.003), (-0.109, -0.021, -0.002),
        (-0.109, -0.022, 0.0), (-0.109, -0.021, 0.002), (-0.109, -0.02, 0.003),
        (-0.109, -0.019, 0.004), (-0.08, -0.014, 0.001), (-0.079, -0.014, 0.001),
        (-0.079, -0.014, 0.001), (-0.078, -0.014, 0.001), (-0.078, -0.014, -0.0),
        (-0.078, -0.014, -0.001), (-0.079, -0.014, -0.001), (-0.079, -0.014, -0.001),
        (-0.08, -0.014, -0.001), (-0.08, -0.014, -0.001), (-0.081, -0.014, -0.001),
        (-0.081, -0.014, -0.001), (-0.081, -0.014, 0.0), (-0.081, -0.014, 0.001),
        (-0.081, -0.014, 0.001), (-0.08, -0.014, 0.001), (-0.08, 0.0, 0.001),
        (-0.079, 0.0, 0.001), (-0.079, 0.0, 0.001), (-0.078, 0.0, 0.001),
        (-0.078, 0.0, -0.0), (-0.078, 0.0, -0.001), (-0.079, 0.0, -0.001),
        (-0.079, 0.0, -0.001), (-0.08, 0.0, -0.001), (-0.08, 0.0, -0.001),
        (-0.081, 0.0, -0.001), (-0.081, 0.0, -0.001), (-0.081, 0.0, 0.0),
        (-0.081, 0.0, 0.001), (-0.081, 0.0, 0.001), (-0.08, 0.0, 0.001)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (0, 48, 63, 15), (14, 62, 61, 13), (59, 58, 10, 11),
        (2, 50, 49, 1), (7, 55, 54, 6), (63, 62, 14, 15),
        (61, 60, 12, 13), (5, 53, 52, 4), (52, 51, 3, 4),
        (3, 51, 50, 2), (58, 57, 9, 10), (60, 59, 11, 12),
        (57, 56, 8, 9), (8, 56, 55, 7), (49, 48, 0, 1),
        (17, 16, 32, 33),
        (32, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33),
        (28, 27, 43, 44),
        (26, 25, 41, 42), (24, 23, 39, 40), (22, 21, 37, 38),
        (20, 19, 35, 36), (16, 31, 47, 32), (18, 17, 33, 34),
        (29, 28, 44, 45), (27, 26, 42, 43), (25, 24, 40, 41),
        (23, 22, 38, 39), (21, 20, 36, 37), (31, 30, 46, 47),
        (19, 18, 34, 35), (30, 29, 45, 46), (65, 81, 80, 64),
        (80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95),
        (76, 92, 91, 75), (74, 90, 89, 73),
        (72, 88, 87, 71), (70, 86, 85, 69), (68, 84, 83, 67),
        (64, 80, 95, 79), (66, 82, 81, 65), (77, 93, 92, 76),
        (75, 91, 90, 74), (73, 89, 88, 72), (71, 87, 86, 70),
        (69, 85, 84, 68), (79, 95, 94, 78), (67, 83, 82, 66),
        (78, 94, 93, 77),
        (0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1),
        (48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63),
        (54, 53, 5, 6)
        ]])
    matids.extend([mat_handle for i in range(52)])
    uvs.extend([
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.058, 0.016), (0.042, 0.014), (0.968, 0.031), (0.977, 0.03)],
        [(0.968, 0.031), (0.959, 0.03), (0.953, 0.029), (0.948, 0.026),
        (0.945, 0.024), (0.944, 0.021), (0.946, 0.018), (0.949, 0.016),
        (0.954, 0.014), (0.96, 0.014), (0.968, 0.014), (0.977, 0.015),
        (0.989, 0.018), (1.0, 0.023), (0.988, 0.027), (0.977, 0.03)],
        [(0.041, 0.001), (0.058, 0.0), (0.944, 0.021), (0.945, 0.024)],
        [(0.071, 0.0), (0.082, 0.001), (0.949, 0.016), (0.946, 0.018)],
        [(0.09, 0.003), (0.094, 0.006), (0.96, 0.014), (0.954, 0.014)],
        [(0.096, 0.008), (0.095, 0.011), (0.977, 0.015), (0.968, 0.014)],
        [(0.09, 0.013), (0.083, 0.015), (1.0, 0.023), (0.989, 0.018)],
        [(0.042, 0.014), (0.022, 0.012), (0.959, 0.03), (0.968, 0.031)],
        [(0.072, 0.016), (0.058, 0.016), (0.977, 0.03), (0.988, 0.027)],
        [(0.022, 0.003), (0.041, 0.001), (0.945, 0.024), (0.948, 0.026)],
        [(0.058, 0.0), (0.071, 0.0), (0.946, 0.018), (0.944, 0.021)],
        [(0.082, 0.001), (0.09, 0.003), (0.954, 0.014), (0.949, 0.016)],
        [(0.094, 0.006), (0.096, 0.008), (0.968, 0.014), (0.96, 0.014)],
        [(0.095, 0.011), (0.09, 0.013), (0.989, 0.018), (0.977, 0.015)],
        [(0.022, 0.012), (0.0, 0.007), (0.953, 0.029), (0.959, 0.03)],
        [(0.083, 0.015), (0.072, 0.016), (0.988, 0.027), (1.0, 0.023)],
        [(0.0, 0.007), (0.022, 0.003), (0.948, 0.026), (0.953, 0.029)],
        [(0.0, 0.074), (0.091, 0.085), (0.089, 0.071), (0.0, 0.096)],
        [(0.089, 0.071), (0.091, 0.085), (0.088, 0.099), (0.08, 0.111),
        (0.068, 0.119), (0.054, 0.122), (0.041, 0.119), (0.029, 0.111),
        (0.022, 0.099), (0.02, 0.085), (0.023, 0.071), (0.03, 0.059),
        (0.042, 0.051), (0.056, 0.048), (0.07, 0.051), (0.081, 0.059)],
        [(0.066, 0.139), (0.042, 0.051), (0.03, 0.059), (0.086, 0.131)],
        [(0.102, 0.116), (0.023, 0.071), (0.02, 0.085), (0.11, 0.096)],
        [(0.11, 0.075), (0.022, 0.099), (0.029, 0.111), (0.101, 0.055)],
        [(0.086, 0.039), (0.041, 0.119), (0.054, 0.122), (0.066, 0.031)],
        [(0.044, 0.031), (0.068, 0.119), (0.08, 0.111), (0.024, 0.039)],
        [(0.0, 0.096), (0.089, 0.071), (0.081, 0.059), (0.009, 0.116)],
        [(0.008, 0.054), (0.088, 0.099), (0.091, 0.085), (0.0, 0.074)],
        [(0.044, 0.139), (0.056, 0.048), (0.042, 0.051), (0.066, 0.139)],
        [(0.086, 0.131), (0.03, 0.059), (0.023, 0.071), (0.102, 0.116)],
        [(0.11, 0.096), (0.02, 0.085), (0.022, 0.099), (0.11, 0.075)],
        [(0.101, 0.055), (0.029, 0.111), (0.041, 0.119), (0.086, 0.039)],
        [(0.066, 0.031), (0.054, 0.122), (0.068, 0.119), (0.044, 0.031)],
        [(0.009, 0.116), (0.081, 0.059), (0.07, 0.051), (0.024, 0.131)],
        [(0.024, 0.039), (0.08, 0.111), (0.088, 0.099), (0.008, 0.054)],
        [(0.024, 0.131), (0.07, 0.051), (0.056, 0.048), (0.044, 0.139)],
        [(0.5, 1.0), (0.691, 0.962), (0.854, 0.854), (0.962, 0.691),
        (1.0, 0.5), (0.962, 0.309), (0.854, 0.146), (0.691, 0.038),
        (0.5, 0.0), (0.309, 0.038), (0.146, 0.146), (0.038, 0.309),
        (0.0, 0.5), (0.038, 0.691), (0.146, 0.854), (0.309, 0.962)],
        [(0.5, 1.0), (0.691, 0.962), (0.854, 0.854), (0.962, 0.691),
        (1.0, 0.5), (0.962, 0.309), (0.854, 0.146), (0.691, 0.038),
        (0.5, 0.0), (0.309, 0.038), (0.146, 0.146), (0.038, 0.309),
        (0.0, 0.5), (0.038, 0.691), (0.146, 0.854), (0.309, 0.962)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        ])


def handle_08(tM, verts, faces, matids, uvs):
    f = len(verts)
    verts.extend([tM * Vector(v) for v in [
        (-0.5, 1.0, 0.5), (-0.5, 0.9, 0.5), (-0.5, 0.9, -0.389),
        (-0.5, 1.0, -0.5), (-0.5, 0.1, -0.389), (-0.5, -0.0, -0.5),
        (-0.5, 0.1, -0.278), (-0.5, -0.0, -0.278), (0.5, 1.0, 0.5),
        (0.5, 0.9, 0.5), (0.5, 0.9, -0.389), (0.5, 1.0, -0.5),
        (0.5, 0.1, -0.389), (0.5, -0.0, -0.5), (0.5, 0.1, -0.278),
        (0.5, -0.0, -0.278)
        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        (7, 15, 14, 6), (9, 8, 0, 1), (10, 9, 1, 2),
        (12, 10, 2, 4), (3, 5, 7, 6, 4, 2, 1, 0), (14, 12, 4, 6),
        (15, 7, 5, 13), (3, 11, 13, 5), (8, 11, 3, 0),
        (11, 8, 9, 10, 12, 14, 15, 13)
        ]])
    matids.extend([mat_handle for i in range(10)])
    uvs.extend([
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.5, 1.0), (0.854, 0.854), (1.0, 0.5), (0.854, 0.146),
        (0.5, 0.0), (0.146, 0.146), (0.0, 0.5), (0.146, 0.854)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
        [(0.5, 1.0), (0.854, 0.854), (1.0, 0.5), (0.854, 0.146),
        (0.5, 0.0), (0.146, 0.146), (0.0, 0.5), (0.146, 0.854)]
        ])


def handle_05(tM, verts, faces, matids, uvs):
    f = len(verts)
    verts.extend([tM * Vector(v) for v in [

        ]])
    faces.extend([tuple([f + i for i in v]) for v in [
        ]])
    matids.extend([2 for i in range(9)])
    uvs.extend([
        ])


# ------------------------------------------------------------------
# Define property group class for cabinet doors
# This is managed as an array of objects
# ------------------------------------------------------------------
class archipack_kitchen_module(ArchipackObject, PropertyGroup):
    """
     Vertical module inside kitchen
    """
    type = EnumProperty(
            name="Type",
            items=(
                ("1", "Drawer", "Drawer"),
                ("2", "Door L", "Door Left"),
                ("3", "Door R", "Door Right"),
                ("4", "Door T", "Door Top"),
                # ("6", "Door B", "Door Bottom"),
                ("5", "Double door", "Double Door"),
                ("6", "Board only", "Board only"),
                ("12", "Door L w glass", "Door Left with glass"),
                ("13", "Door R w glass", "Door Right with glass"),
                ("14", "Door T w glass", "Door Top with glass"),
                ("15", "Double w glass", "Double with glass"),
                ("54", "Oven", "Oven"),
                ("55", "Range hood", "Range hood"),
                # ("56", "Microwave", "Microwave"),
                # ("58", "Freezer", "Freezer"),
                ("59", "Dishwasher", "Dishwasher"),
                ("0", "None", "None"),
                ),
            default="1",
            update=update_parent
            )
    modules = IntProperty(
            name="Height",
            description="#modules 0=user defined 1=12.7 cm - 5",
            min=0, max=16, default=6,
            update=update_parent
            )
    z = FloatProperty(
            name="Height",
            min=0.01, default=0.762,
            unit='LENGTH', subtype='DISTANCE',
            update=update_parent
            )
    shelves = IntProperty(
            name='Shelves', min=0, max=10, default=1,
            description='Number total of shelves',
            update=update_parent,
            )
    handle = BoolProperty(
            name="Handle",
            description="Create a handle", default=True,
            update=update_parent,
            )
    auto_update = BoolProperty(
            options={'SKIP_SAVE'},
            name="auto_update",
            description="disable auto update to avoid infinite recursion",
            default=True
            )

    @property
    def n_panels(self):
        if self.type in {'5', '15'}:
            return 2
        elif self.type == '0':
            return 0
        return 1

    def draw(self, layout, num, z_mode):
        module_type = int(self.type)

        row = layout.row(align=True)
        row.prop(self, 'type', text="Door " + str(num))
        if module_type < 50:
            row.prop(self, 'handle', text="")

        row = layout.row(align=True)
        if z_mode == 1:
            row.prop(self, 'modules')

        if z_mode > 1 or self.modules == 0:
            row.prop(self, 'z')

        if module_type < 50 and module_type not in {1, 4}:
            row.prop(self, 'shelves')

    def door(self, size, border, thickness, chanfer, style, mat):

        x0 = 0
        x1 = border 
        x2 = x1 - chanfer
        x3 = chanfer
        w = thickness
        # offset pivot point on outside part
        y0 = 0
        y1 = y0 + w
        y2 = y1 - 0.5 * w
        y3 = y1 - chanfer
        y4 = y0 + chanfer
        verre = 0.002

        # profil carre avec support pour verre
        # p ______       y1
        # / |      y3
        # |       |___
        # x       |___   y2  verre
        # |       |      y4
        #  \______|      y0
        # x0 x3 x2 x1
        # outside

        # flat board
        if style == 1:
            return Lofter(
                False,  # closed
                [0, 0],  # x index
                [x0],
                [y0, y1],
                [mat, mat],  # materials
                side_cap_front=1,
                side_cap_back=0      # cap index
                )

        # board with frame
        elif style == 2:
            return Lofter(
                False,  # closed
                [1, 1, 0, 0],  # x index
                [x0, x1],
                [y2, y0, y0, y1],
                [mat_border for i in range(4)],  # materials
                side_cap_front=3,
                side_cap_back=0      # cap index
                )

        # board with chanfer
        elif style == 11:
            return Lofter(
                False,  # closed
                [1, 0, 0, 1],  # x index
                [x0, x3],
                [y0, y4, y3, y1],
                [mat, mat, mat, mat],  # materials
                side_cap_front=3,
                side_cap_back=0      # cap index
                )

        # board with chanfer and frame
        elif style == 12:
            # fallback to panel without border
            # when border > size
            return Lofter(
                False,  # closed
                [3, 3, 2, 1, 0, 0],  # x index
                [x0, x3, x2, x1],
                [y2, y4, y0, y0, y4, y1],
                [mat_border for i in range(6)],  # materials
                side_cap_front=5,
                side_cap_back=0      # cap index
                )

        # board with glass
        elif style == 21:
            return Lofter(
                True,  # closed
                [0, 0, 1, 1, 1, 1],  # x index
                [x0, x1],
                [y0, y1, y1, y2 + verre, y2 - verre, y0],
                [mat for i in range(6)],  # materials
                side_cap_front=3,
                side_cap_back=4      # cap index
                )

        # board with chanfer and glass
        elif style == 22:
            # fallback to panel without border
            # when border > size
            return Lofter(
                True,  # closed
                [1, 0, 0, 2, 2, 2, 2, 3],  # x index
                [x0, x3, x1, x2],
                [y0, y4, y1, y1, y2 + verre, y2 - verre, y4, y0],
                [mat for i in range(8)],  # materials
                side_cap_front=4,
                side_cap_back=5      # cap index
                )

    def find_datablock_in_selection(self, context):
        """
            find witch selected object this instance belongs to
            provide support for "copy to selected"
        """
        selected = [o for o in context.selected_objects]
        for o in selected:
            props = archipack_kitchen.datablock(o)
            if props:
                for cabinet in props.cabinets:
                    for module in cabinet.modules:
                        if module == self:
                            return props
        return None

    def update_parent(self, context):

        if self.auto_update:
            print("module.update_parent()")

            props = self.find_datablock_in_selection(context)
            if props is not None:
                print("module.update_parent() cabinet found")
                props.update(context)

    def update(self, context, size, pivot, kitchen, cab, module, handle_location):
        """
          kitchen_module may produce more than one child object
          so not every object's kitchen_module belong to cabs
          this update func dosent rely on this particular datablock
        """
        o = self.find_in_selection(context)

        if o is None:
            return

        border = kitchen.door_x
        style = int(kitchen.door_style)
        handle_style = int(kitchen.handle)
        module_type = int(module.type)
        cab_location = cab.location
        th = kitchen.thickness

        if 10 < module_type < 20:
            # module with glass
            style = 20 + style % 10

        mat_side, mat_ext, mat_int = cab_location, cab_location, mat_inside
        border_overflow = 2 * border > size.y or 2 * border > size.x

        if border_overflow:
            # style with frame
            if style % 10 == 2:
                # face is of border mat
                mat_ext = mat_border
                mat_side = mat_border
            # fallback to panel without border
            if style in {2, 21}:
                style = 1
            elif style in {12, 22}:
                style = 11

        # glass and no overflow
        if style > 20:
            mat_ext, mat_int = 8, 8

        if module_type > 50:
            verts, faces, matids, uvs = [], [], [], []

            if module_type == 54:
                oven_door(size, verts, faces, matids, uvs)
            elif module_type == 59:
                # might use resized panel and add part on top
                dishwasher_door(size, verts, faces, matids, uvs)

        else:

            offset = Vector((0, 0, 0))
            center = Vector((0, 0, 0))
            origin = Vector((0, 0, 0))
            radius = Vector((0, 0, 0))
            board_size = size.copy()

            # negative handle follow special rule
            # when door size > bottom size handle goes on panel side
            # otherwise handle on panel top / bottom
            handle_on_side = False
            if module.handle and handle_style == 8:
                if size.y <= kitchen.height_default:
                    board_size.y -= kitchen.handle_x
                    # offset door model for bottom handle
                    if handle_location == 0:
                        offset.y = kitchen.handle_x
                else:
                    handle_on_side = True
                    board_size.x -= kitchen.handle_x

            door = self.door(board_size, border, kitchen.door_y, kitchen.door_chanfer, style, mat_side)

            verts = door.vertices(1, offset, center, origin, board_size,
                radius, 0, pivot, shape_z=None, path_type='RECTANGLE')

            faces = door.faces(1, path_type='RECTANGLE')

            uvs = door.uv(1, center, origin, board_size,
                radius, 0, pivot, border, 0, path_type='RECTANGLE')

            matids = door.mat(1, mat_int, mat_ext, path_type='RECTANGLE')

            # -------------
            # Drawer
            # -------------
            if module_type == 1:
                # drawer
                sy = kitchen.y + cab.dy - th
                if cab_location == 2:
                    sy = kitchen.yw + cab.dy - th
                x0 = 0.5 * size.x * pivot
                y0 = kitchen.door_y
                y1 = y0 + sy - th
                sx = 0.5 * size.x - th
                z0 = 2 * th
                z1 = 0.5 * size.y
                tM = Matrix()
                # sides
                make_box(tM, x0 + sx - th, x0 + sx, y0, y1, z0, z1, 0,
                    mat_inside, False, verts, faces, matids, uvs)
                make_box(tM, x0 - sx, x0 + th - sx, y0, y1, z0, z1, 0,
                    mat_inside, False, verts, faces, matids, uvs)
                # back
                make_box(tM, x0 - sx, x0 + sx, sy, y1 + th, z0, z1, 0,
                    mat_inside, False, verts, faces, matids, uvs)
                # bottom
                make_box(tM, x0 - sx, x0 + sx, y0, y1 + th, z0 - th, z0, 0,
                    mat_inside, False, verts, faces, matids, uvs)

            # -------------
            # Handles
            # -------------
            if module_type != 6 and module_type < 50 and module.handle:

                # offset from borders
                handle_offset_x = min(kitchen.handle_x, size.x, size.y)
                handle_offset_z = min(kitchen.handle_z, size.x, size.y)

                s = kitchen.handle_scale

                if handle_style == 8:
                    # offset is half handle size
                    handle_offset_x /= 2
                    # change side / top-bottom rules
                    if handle_on_side:
                        module_type = 0
                    else:
                        module_type = 1

                if module_type in {1, 4}:
                    # drawer / door top - bottom
                    if handle_location == 0:
                        z = handle_offset_x
                    else:
                        z = handle_location * size.y - handle_offset_x

                    # Drawer - horizontal handle
                    tM = Matrix([
                        [s, 0, 0, pivot * (0.5 * size.x)],
                        [0, s, 0, 0],
                        [0, 0, s, z],
                        [0, 0, 0, 1]
                    ])
                else:

                    if handle_location == 0:
                        z = handle_offset_z
                    else:
                        z = handle_location * size.y - handle_offset_z

                    # Door - vertical handle
                    tM = Matrix([
                        [0, 0, pivot * s, pivot * (size.x - handle_offset_x)],
                        [0, s, 0, 0],
                        [-pivot * s, 0, 0, z],
                        [0, 0, 0, 1]
                    ])

                if handle_style == 1:
                    handle_01(tM, verts, faces, matids, uvs)
                elif handle_style == 2:
                    handle_02(tM, verts, faces, matids, uvs)
                elif handle_style == 3:
                    handle_03(tM, verts, faces, matids, uvs)
                elif handle_style == 4:
                    handle_04(tM, verts, faces, matids, uvs)
                elif handle_style == 12:
                    # scale to fit door size
                    tM[0][0] = tM[0][0] * (size.x - handle_offset_z) / (s * 0.182)
                    tM[2][0] = tM[2][0] * (size.y - handle_offset_z) / (s * 0.182)
                    # remove z offset
                    if tM[0][2] != 0:
                        tM[2][3] = 0.5 * size.y
                    handle_02(tM, verts, faces, matids, uvs)
                elif handle_style == 8:

                    # rescale bottom handles to revert
                    zs = 1
                    if handle_location == 0:
                        zs = -1

                    # scale to fit door size
                    # y
                    tM[1][1] = tM[1][1] * kitchen.door_y / s
                    # z
                    tM[0][2] = tM[0][2] * 2 * handle_offset_x / s
                    tM[2][2] = zs * tM[2][2] * 2 * handle_offset_x / s
                    # x
                    tM[0][0] = zs * tM[0][0] * size.x / s
                    tM[2][0] = tM[2][0] * size.y / s

                    # remove z offset
                    if handle_on_side:
                        tM[2][3] = 0.5 * size.y

                    handle_08(tM, verts, faces, matids, uvs)
                # for future use
                elif handle_style == 5:
                    handle_01(tM, verts, faces, matids, uvs)
                elif handle_style == 6:
                    handle_01(tM, verts, faces, matids, uvs)
                elif handle_style == 7:
                    handle_01(tM, verts, faces, matids, uvs)

        bmed.buildmesh(context, o, verts, faces, matids, uvs)

        self.restore_context(context)


class archipack_kitchen_cabinet(ArchipackObject, PropertyGroup):
    # Define properties
    type = EnumProperty(
            # 0 for regular, 1 corner L, 2 corner R, 3 corner L+R
            items=(
                ('0', "Cabinet", ""),
                ('1', "Corner L", ""),
                ('2', "Corner R", ""),
                ('3', "Corner 45 degree", ""),
                ('4', "Cabinet without left side", ""),
                ('5', "Cabinet without right side", ""),
                ('6', "Cabinet without sides", ""),
                ('7', "Corner 45 degree without sides", ""),
                ),
            name="Type",
            default="0",
            description="Type of cabinet",
            update=update
            )
    cab_location = EnumProperty(
            items=(
                ('1', "Floor", ""),
                ('2', "Wall", ""),
                ('3', "Full", ""),
                ),
            name="Location",
            default="1",
            description="Location of cabinet",
            update=update
            )
    # Cabinet width
    x = FloatProperty(
            name='width', min=0.001, default=0.60, precision=3,
            description='Cabinet width',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    dy = FloatProperty(
            name='y', default=0, precision=3,
            description='Modify depth',
            unit='LENGTH', subtype='DISTANCE',
            update=update,
            )
    dz = FloatProperty(
            name='z', default=0, precision=3,
            description='Modify height',
            unit='LENGTH', subtype='DISTANCE',
            update=update,
            )

    # Cabinet position shift
    reset_location = BoolProperty(
            name="Reset",
            description="Reset location", default=False,
            update=update,
            )
    px = FloatProperty(
            name='x', default=0, precision=3,
            description='Position x shift',
            unit='LENGTH', subtype='DISTANCE',
            update=update,
            )
    py = FloatProperty(
            name='y', default=0, precision=3,
            description='Position y shift',
            unit='LENGTH', subtype='DISTANCE',
            update=update,
            )
    pz = FloatProperty(
            name='z', default=0, precision=3,
            description='Position z shift',
            unit='LENGTH', subtype='DISTANCE',
            update=update,
            )
    lock_p = BoolProperty(
        name="Lock",
        description="Move next cabs too",
        default=True,
        update=update
        )

    # Doors
    n_modules = IntProperty(
        name="Doors",
        min=0, max=16, default=1,
        update=update
        )
    modules = CollectionProperty(type=archipack_kitchen_module)
    expand = BoolProperty(
            options={'SKIP_SAVE'},
            name="expand",
            description="Expand cabinet panel",
            default=False
            )

    # baseboard
    baseboard = BoolProperty(
            name="Baseboard",
            description="Create a baseboard automatically",
            default=True,
            update=update
            )
    base_left = BoolProperty(
            name="Left",
            description="Create a left baseboard", default=False,
            update=update,
            )
    base_right = BoolProperty(
            name="Right",
            description="Create a right baseboard", default=False,
            update=update,
            )
    base_sink = FloatProperty(
        name='sink', min=0,
        default=0.05, precision=3,
        description='Baseboard side sink',
        unit='LENGTH', subtype='DISTANCE',
        update=update
        )

    # side boards
    panel_left_width = FloatProperty(
            name="L board",
            description="Width of left side board",
            min=0.001, default=0.018,
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    panel_right_width = FloatProperty(
            name="R board",
            description="Width of right side board",
            min=0.001, default=0.018,
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    panel_left = BoolProperty(
            name="Left",
            description="Create a left side board", default=False,
            update=update,
            )
    panel_right = BoolProperty(
            name="Right",
            description="Create a right side board", default=False,
            update=update,
            )

    # Countertop
    counter = EnumProperty(
            name="Countertop",
            items=(
                ('0', 'No Countertop', 'Disable countertop'),
                ('1', 'Countertop', 'Countertop regular'),
                ('2', 'Cook top', 'Countertop with cook top'),
                # 10+ create hole in countertop
                ('11', 'Sink', 'Countertop with sink'),
                ('12', 'Countertop hole', 'Countertop with hole'),
                ),
            default='1',
            update=update,
            description="Create counter"
            )
    counter_fill = BoolProperty(
            name="Fill",
            description="Fill empty spaces with counter",
            default=False,
            update=update,
            )
    counter_x = FloatProperty(
            name="Width",
            description="Width",
            min=0.001, default=0.5,
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    counter_y = FloatProperty(
            name="Length",
            description="Length",
            min=0.001, default=0.4,
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )

    # cabinet rotation
    rotate = EnumProperty(
            items=(
                ('0', "No rotation", ""),
                ('1', "90 CW", ""),
                ('2', "90 CCW", ""),
                ('3', "180", ""),
                ('4', "User defined", "")
                ),
            name="Rot",
            description="Rotate cabinet relative to previous one",
            update=update,
            )
    angle = FloatProperty(
            name="Angle",
            description="User defined rotation",
            default=0,
            subtype='ANGLE', unit='ROTATION',
            update=update
            )

    manipulators = CollectionProperty(type=archipack_manipulator)
    auto_update = BoolProperty(
            options={'SKIP_SAVE'},
            name="auto_update",
            description="disable auto update to avoid infinite recursion",
            default=True
            )

    @property
    def location(self):
        """
         also define material id for doors and sides
         1 for floor, 2 for wall, 3 for full
        """
        return int(self.cab_location)

    @property
    def cab_type(self):
        """
         0 for regular, 1 corner L, 2 corner R, 3 corner L+R
        """
        return int(self.type)

    @property
    def countertop_hole(self):
        """ Test if hole is needed in countertop
        """
        return int(self.counter) > 10 and self.location == 1

    @property
    def board_left(self):
        """ Space in use for left board and """
        if self.panel_left and self.cab_type != 2:
            return self.panel_left_width
        else:
            return 0

    @property
    def board_right(self):
        """ Space in use for right board"""
        if self.panel_right and self.cab_type != 1:
            return self.panel_right_width
        else:
            return 0

    def find_datablock_in_selection(self, context):
        """
            find witch selected object this instance belongs to
            provide support for "copy to selected"
        """
        selected = [o for o in context.selected_objects]
        for o in selected:
            props = archipack_kitchen.datablock(o)
            if props:
                for cab in props.cabinets:
                    if cab == self:
                        return props
        return None

    def update_parts(self):
        # remove modules
        for i in range(len(self.modules), self.n_modules, -1):
            self.modules.remove(i - 1)

        # add modules
        for i in range(len(self.modules), self.n_modules):
            self.modules.add()

    def update(self, context):
        print("cabinet.update()")
        if self.auto_update:

            self.update_parts()
            props = self.find_datablock_in_selection(context)
            if props is not None:
                print("cabinet.update() kitchen found")

                props.update(context)

    def draw(self, box, num, prop):

        row = box.row(align=True)

        if self.expand:
            row.prop(self, "expand", icon="TRIA_DOWN", icon_only=True, text="Cab " + str(num + 1), emboss=False)
        else:
            row.prop(self, "expand", icon="TRIA_RIGHT", icon_only=True, text="Cab " + str(num + 1), emboss=False)
        row.prop(self, 'cab_location', text="")
        row.prop(self, 'type', text="")
        row.operator("archipack.kitchen_insert", icon="ZOOMIN", text="").index = num
        row.operator("archipack.kitchen_remove", icon="ZOOMOUT", text="").index = num

        if self.expand:

            row = box.row(align=True)
            row.prop(self, 'x')
            row.prop(self, 'dy')
            row.prop(self, 'dz')

            row = box.row(align=True)
            row.prop(self, 'px')
            row.prop(self, 'py')
            row.prop(self, 'pz')
            if self.lock_p:
                row.prop(self, 'lock_p', icon="LOCKED", text="")
            else:
                row.prop(self, 'lock_p', icon="UNLOCKED", text="")

            row = box.row(align=True)
            row.prop(self, 'reset_location')
            row.prop(self, 'rotate', text="")
            if self.rotate == '4':
                row.prop(self, 'angle', text="")

            if self.location == 1:
                if prop.counter:
                    row = box.row(align=True)
                    row.prop(self, 'counter', text="")
                    if self.counter != '0':
                        row.prop(self, 'counter_fill', text="")
                    if int(self.counter) > 1:
                        row = box.row(align=True)
                        row.prop(self, 'counter_x')
                        row.prop(self, 'counter_y')

            if self.location != 2:
                if prop.baseboard:
                    row = box.row(align=True)
                    row.prop(self, 'baseboard', text="Baseboard")
                    if self.baseboard:
                        row.prop(self, 'base_sink', text="")
                        row.prop(self, 'base_left', text="")
                        row.prop(self, 'base_right', text="")

            row = box.row(align=True)
            row.prop(self, 'panel_left_width')
            row.prop(self, 'panel_left', text="")
            row.prop(self, 'panel_right_width')
            row.prop(self, 'panel_right', text="")

            row = box.row()
            row.prop(self, 'n_modules')
            for i, module in enumerate(reversed(self.modules)):
                module.draw(box, self.n_modules - i, int(prop.z_mode))


class archipack_kitchen(ArchipackObject, Manipulable, PropertyGroup):

    door_style = EnumProperty(
            name='Doors',
            items=(
                ('1', 'Flat', 'Simple board without chanfer'),
                ('2', 'Flat with frame', 'Board with frame'),
                ('11', 'Chanfer', 'Simple board with chanfer'),
                ('12', 'Frame and chanfer', 'Board with frame and chanfer'),
                ),
            default='11',
            update=update
            )
    door_x = FloatProperty(
            name='Border', min=0.001, default=0.08, precision=3,
            description='Door border width',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    door_y = FloatProperty(
            name='Thick', min=0.001, default=0.018, precision=3,
            description='Door thickness',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    door_chanfer = FloatProperty(
            name='Chanfer', min=0, default=0.001, precision=3,
            description='Door chanfer',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )

    thickness = FloatProperty(
            name='Thickness', min=0.001, default=0.018, precision=3,
            description='Board thickness',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    y = FloatProperty(
            name='Depth', min=0.001, default=0.59, precision=3,
            description='Default cabinet depth',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    yw = FloatProperty(
            name='Wall Depth', min=0.001, default=0.39, precision=3,
            description='Default wall cabinet depth',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )

    z_mode = EnumProperty(
            name='Z mode',
            items=(
                ('1', 'Height Multiplier', 'Height are multiples of base height, default 6/6/16 modules'),
                ('2', 'Height Absolute', 'Height are absolute values'),
                ),
            default='1',
            update=update
            )
    module_size = FloatProperty(
            name='Height', min=0.001, default=0.127, precision=3,
            description='Base height for multiplier, default (12.7cm / 5")',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    modules_default = IntProperty(
            name="Default",
            description='#Modules for default cabinet (default = 6)',
            min=1, default=6,
            update=update
            )
    modules_wall = IntProperty(
            name="Wall",
            description='#Modules for wall cabinet (default = 6)',
            min=1, default=6,
            update=update)
    modules_full = IntProperty(
            name="Full",
            description='#Modules for full height cabinet (default = 16)',
            min=1, default=16,
            update=update
            )
    z_default = FloatProperty(
            name="Default",
            unit='LENGTH', subtype='DISTANCE',
            description='Height for default cabinet',
            min=0.001, default=0.762, precision=3,
            update=update
            )
    z_wall = FloatProperty(
            name="Wall",
            unit='LENGTH', subtype='DISTANCE',
            description='Height for wall cabinet',
            min=0.001, default=0.762, precision=3,
            update=update)
    z_full = FloatProperty(
            name="Full",
            unit='LENGTH', subtype='DISTANCE',
            description='Height for full height cabinet',
            min=0.001, default=2.032, precision=3,
            update=update
            )

    handle = EnumProperty(
            items=(
                ('1', "Standard", ""),
                ('2', "Rail", ""),
                ('3', "Round", ""),
                ('4', "Tubes", ""),
                ('12', "Rail fit width/height", ""),
                # ('5', "Handle 5", ""),
                # ('6', "Handle 6", ""),
                # ('7', "Handle 7", ""),
                ('8', "Gap", ""),
                ('9', "None", ""),
                ),
            name="Handle",
            description="Type of handle",
            update=update
            )
    handle_x = FloatProperty(
            name='x', min=0.001,
            default=0.05, precision=3,
            description='Displacement in X relative position (limited to door size)',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    handle_z = FloatProperty(
            name='z', min=0.001,
            default=0.15, precision=3,
            description='Displacement in Z relative position (limited to door size)',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    handle_scale = FloatProperty(
            name='scale', min=0.01, default=1.0,
            precision=3,
            description='Handle scale',
            update=update
            )

    baseboard = BoolProperty(
            name="Baseboard",
            description="Create a baseboard automatically",
            default=True,
            update=update
            )
    base_height = FloatProperty(
            name='height', min=0.001,
            default=0.16, precision=3,
            description='Baseboard height',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    base_sink = FloatProperty(
            name='sink', min=0,
            default=0.05, precision=3,
            description='Baseboard sink',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )

    counter = BoolProperty(
            name="Countertop",
            description="Create a countertop automatically (only default cabinet)",
            default=True,
            update=update
            )
    counter_z = FloatProperty(
            name='height', min=0.001,
            default=0.02, precision=3,
            description='Countertop height',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    counter_y = FloatProperty(
            name='extend', min=0.001,
            default=0.03, precision=3,
            description='Countertop extent',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )
    counter_chanfer = FloatProperty(
            name='chanfer', min=0.0001,
            default=0.001, precision=3,
            description='Countertop chanfer',
            unit='LENGTH', subtype='DISTANCE',
            update=update
            )

    cabinet_num = IntProperty(
            name='#Cabinets', min=1,
            default=1,
            description='Number total of cabinets in the Kitchen',
            update=update_manipulators
            )
    cabinets = CollectionProperty(type=archipack_kitchen_cabinet)
    expand = BoolProperty(
            options={'SKIP_SAVE'},
            name="expand",
            description="Expand kitchen properties",
            default=False
            )

    auto_update = BoolProperty(
            options={'SKIP_SAVE'},
            default=True,
            update=update_manipulators
            )

    @property
    def height_default(self):
        if self.z_mode == '1':
            return self.module_size * self.modules_default
        else:
            return self.z_default

    @property
    def height_wall(self):
        if self.z_mode == '1':
            return self.module_size * self.modules_wall
        else:
            return self.z_wall

    @property
    def height_full(self):
        if self.z_mode == '1':
            return self.module_size * self.modules_full
        else:
            return self.z_full

    @property
    def altitude_wall(self):
        if self.z_mode == '1':
            return self.module_size * (self.modules_full - self.modules_wall)
        else:
            return self.z_full - self.z_wall

    def cabinet_depth(self, cab):
        if cab.location == 2:
            y = self.yw
        else:
            y = self.y
        return y
    
    def cabinet_height(self, cab):
        cab_location = cab.location
        if cab_location == 1:
            return self.height_default + cab.dz
        elif cab_location == 2:
            return self.height_wall + cab.dz
        else:
            return self.height_full + cab.dz
        
    def insert_part(self, context, where):
        self.manipulable_disable(context)
        self.auto_update = False
        self.cabinets.add()
        # move after current one
        self.cabinets.move(len(self.cabinets) - 1, where + 1)
        self.cabinet_num += 1
        self.setup_manipulators()
        self.auto_update = True

    def remove_part(self, context, where):
        self.manipulable_disable(context)
        self.auto_update = False
        self.cabinets.remove(where)
        self.cabinet_num -= 1
        self.setup_manipulators()
        self.auto_update = True
    
    def create_cabinet(self, cab, tM, verts, faces, matids, uvs):
        cab_depth = self.cabinet_depth(cab)
        sx, sy, sz = cab.x, cab_depth + cab.dy, self.cabinet_height(cab)
        door_y = self.door_y
        th = self.thickness
        
        z0 = 0
        z1 = sz
        
        # also define material id
        cab_location = cab.location

        cab_type = cab.cab_type
        countertop_hole = cab.countertop_hole
        door_style = int(self.door_style)
        
        # wall cabinet
        if cab_location == 2:
            # range hood
            module = cab.modules[0]
            if module.type == '55':
                if module.modules == 0 or self.z_mode == '2':
                    # user defined height / absolute z mode
                    zd = module.z
                else:
                    zd = self.module_size * module.modules
                z0 += zd
                
        # Side boards on corners to prevent door opening conflict
        if 0 < cab_type < 3:
            
            sx += self.y

            y0 = -sy - door_y
            y1 = -sy

            if cab_type == 1:
                # Left corner
                sx += max(door_y, cab.panel_right_width)
                x0 = cab.x + self.y - cab_depth
                x1 = cab.x + self.y + cab.dy + max(door_y, cab.panel_right_width)
            elif cab_type == 2:
                # Right corner
                sx += max(door_y, cab.panel_left_width)
                x0 = 0
                x1 = cab_depth + max(door_y, cab.panel_left_width)
            
            make_box(tM, x0, x1, y1, y0, 0, sz, self.door_chanfer,
                cab_location, door_style > 10, verts, faces, matids, uvs)
 
        f = len(verts)
        
        # cabinet box size
        x0 = 0
        x1 = th
        x2 = sx - th
        x3 = sx
        # z top inside variable for cabinets hole on top
        zi = z1 - th

        # gl location of cab number
        m_pos = tM * Vector((0.5 * sx, -0.5 * sy, sz))
        cab.manipulators[0].set_pts([
                m_pos,
                m_pos,
                (-3, 0, 0)
                ])

        if countertop_hole:
            # cabinet with hole on top
            zi = sz
        """
        ('0', "Cabinet", ""),
        ('1', "Corner L", ""),
        ('2', "Corner R", ""),
        ('3', "Corner 45 degree", ""),
        ('4', "Cabinet without left side", ""),
        ('5', "Cabinet without right side", ""),
        ('6', "Cabinet without sides", ""),
        ('7', "Corner 45 degree without sides", ""),
        """
        
        """
            wall
           0  x0____x3   x0 ___ x3
               |    |      |   |
               |    |   -sy\   | 
        y1=-sy |____|    y1 \__| 
        
        """
        
        # corner 45
        chanfer = False
        dy = 0
        y1 = -sy
        
        if cab_type in {3, 7}:
            chanfer = 2
            # 45 degree part
            x3 = cab.x + cab_depth
            y1 = -x3
            dy = cab.x
            x2 = x3
            
        z2 = z0 + th
        # bottom
        make_box(tM, x0, x3, 0, y1, z0, z2, dy, 
            cab_location, chanfer, verts, faces, matids, uvs)
        
        matids[-1] = mat_inside
        
        # back
        make_box(tM, x0, x3, 0, -th, z2, z1, 0, 
            cab_location, False, verts, faces, matids, uvs)
        
        matids[-3] = mat_inside
        
        # L side
        if cab_type not in {4, 6, 7}:
            make_box(tM, x0, x0 + th, -th, -sy, z0 + th, zi, 0, 
                cab_location, False, verts, faces, matids, uvs)
                
            matids[-4] = mat_inside
        else:
            # extend shelves
            x1 -= th
        
        # R side (is back part 2 of 45 degree)
        if cab_type not in {5, 6}:
            make_box(tM, x3 - th, x3, -th, y1, z0 + th, zi, 0, 
                cab_location, False, verts, faces, matids, uvs)
                
            matids[-6] = mat_inside
        else:
            # extend shelves
            x2 += th
            
        # top
        if not countertop_hole:
            make_box(tM, x0, x3, -th, y1, z1 - th, z1, dy, 
                cab_location, chanfer, verts, faces, matids, uvs)
            matids[-2] = mat_inside
            
        # corner 45 "Right" side of in front 
        if cab_type == 3:
            make_box(tM, x0 + dy, x3 - th, y1 + th, y1, z0 + th, z1 - th, 0, 
                cab_location, False, verts, faces, matids, uvs)
            matids[-5] = mat_inside
            # offset shelves
            y1 += th
            dy -= th
            
        # -----------------
        # side boards
        # -----------------
        if cab.panel_left and cab_type != 2:
            x = -cab.board_left
            y = sy + door_y
            make_box(tM, x, 0, 0, -y, 0, sz, self.door_chanfer,
                cab_location, door_style > 10, verts, faces, matids, uvs)

        if cab.panel_right and cab_type != 1:
            # corner 45 "Right" board in front 
            if cab_type in {3, 7}:
                make_box(tM, x0 + dy + th - door_y, x3, y1 - th, y1 - th - cab.board_right, 0, sz, self.door_chanfer, 
                    cab_location, door_style > 10, verts, faces, matids, uvs)
            else:
                x4 = x3 + cab.board_right
                y = sy + door_y
                make_box(tM, x3, x4, 0, -y, 0, sz, self.door_chanfer,
                    cab_location, door_style > 10, verts, faces, matids, uvs)

        # -----------------
        # sink / cook top
        # -----------------
        if cab_location == 1:
            counter_type = int(cab.counter)
            hx = cab.counter_x
            hy = cab.counter_y
            tM2 = tM.copy()
            cx = 0.5 * cab.x
            if cab_type == 2:
                cx += self.y
            cy = 0.5 * (cab_depth + cab.dy)
            r = 0.02
            
            # corner 45 rotate 45 deg
            if cab_type in {3, 7}:
                sq2 = 0.5 * 2 ** 0.5
                tM2 = tM * Matrix([
                    [sq2, sq2, 0, 0.5 * cab.x],
                    [-sq2, sq2, 0, -(cab_depth + cab.dy) - 0.5 * cab.x],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                    ])
                cx = 0 # cab_depth + cab.x
                cy = -0.5 * cab.x  #(cab_depth + cab.dy) + 0.5 * cab.x
            
            if counter_type == 11:
                sink(tM2, cx, -cy, sz + self.counter_z, r, hx, hy, verts, faces, matids, uvs)
            elif counter_type == 2:
                cook_top(tM2, cx, -cy, sz + self.counter_z, r, hx, hy, verts, faces, matids, uvs)

        # -----------------
        # shelves
        # -----------------
        tM2 = tM.copy()
        
        if cab_type in {3, 7}: 
            
            a = pi / 4
            ca = cos(a)
            sa = sin(a)
            x = 0.5 * (cab_depth + cab.dy + door_y) * (2 ** 0.5)
            y = cab_depth + cab.dy + door_y - x
            loc = Vector((
                x * ca + y * sa, 
                x * -sa + y * ca, 
                0))
            sx = (cab.x - door_y) * (2 ** 0.5)   
            tM2 = tM * Matrix([
                [ca, sa, 0, loc.x],
                [-sa, ca, 0, loc.y],
                [0, 0, 1, loc.z],
                [0, 0, 0, 1]
                ])
                
        for i, module in enumerate(cab.modules):

            module_type = int(module.type)

            # Door height
            if module.modules == 0 or self.z_mode == '2':
                # user defined height / absolute z mode
                zd = module.z
            else:
                zd = self.module_size * module.modules

            zd = min(zd, sz - z0)

            if zd == 0:
                continue

            # Drawer and raw face board dosent allow shelves
            if module_type in {1, 6}:
                z0 += zd
                continue

            # calculate separation
            space = zd / (module.shelves + 1)
            z1 = z0 + th
            

            
            if module_type == 54:
                oven_cab(tM2, sx, sy, zd, z0, th, door_y, verts, faces, matids, uvs)
            elif module_type == 55:

                rangehood(tM2, sx, sy, zd, z0 - zd, th, door_y, verts, faces, matids, uvs)
                zd = 0
            elif module_type == 59:
                dishwasher_cab(tM2, sx, sy, zd, z0, th, door_y, verts, faces, matids, uvs)
            else:
                
                # Ground not needed on 1 element
                if i == 0:
                    start = 1
                    z1 += space
                else:
                    start = 0
                
                # shelves
                for x in range(start, module.shelves + 1):
                    f = len(verts)
                    z2 = z1 - th
                    make_box(tM, x1, x2, -th, y1, z2, z1, dy, 
                        mat_inside, chanfer, verts, faces, matids, uvs)

                    z1 += space

            z0 += zd

    def update_cabinets(self, context, verts, faces, matids, uvs):

        # Vector for axis location
        loc = Vector((0, 0, 0))
        a = 0
        ca = 1
        sa = 0
        door_y = self.door_y

        for cab in self.cabinets:

            # side boards size
            board_left = cab.board_left
            board_right = cab.board_right
            cab_depth = self.cabinet_depth(cab)
            
            z = cab.pz
            cab_type = cab.cab_type
            cab_location = cab.location
            
            if self.baseboard:
                z += self.base_height

            # Wall
            if cab_location == 2:
                z += self.altitude_wall - cab.dz

            if cab.reset_location:
                loc = Vector((0, 0, 0))
                a = 0

            # rotate R cab
            if cab_type == 2:

                dx = cab_depth + door_y
                a += pi / 2
                # use last rotation and move basis location
                loc += Vector((dx * ca, dx * -sa, 0))

            else:
                rot_type = int(cab.rotate)
                if rot_type == RotationType_R90CW:
                    a += pi / 2
                elif rot_type == RotationType_R90CCW:
                    a -= pi / 2
                elif rot_type == RotationType_R180:
                    a += pi
                elif rot_type == RotationType_User:
                    a += cab.angle

            # add translation between last and current cab
            ca = cos(a)
            sa = sin(a)
            loc += Vector((
                (board_left + cab.px) * ca + cab.py * sa,
                (board_left + cab.px) * -sa + cab.py * ca,
                z))

            # matrix at cabinet border with z at bottom
            tM = Matrix([
                [ca, sa, 0, loc.x],
                [-sa, ca, 0, loc.y],
                [0, 0, 1, loc.z],
                [0, 0, 0, 1]
                ])
            
            self.create_cabinet(cab, tM, verts, faces, matids, uvs)

            if cab.lock_p:
                dx = cab.x
                dy = 0
                dz = cab.pz - z
            else:
                dx = cab.x - cab.px
                dz = -z
                dy = -cab.py

            # add translation for current cab to border
            if cab_type == 1:
                # Corner L
                a += pi / 2
                dx += self.y + max(door_y, cab.panel_right_width)
                loc = tM * Vector((dx, dy - cab_depth - door_y, dz))
            elif cab_type == 2:
                # Corner R
                dx += self.y + board_right + max(door_y, cab.panel_left_width)
                loc = tM * Vector((dx, 0, dz))
            elif cab_type in {3, 7}:
                # Corner 45
                a += pi / 2
                dx += cab_depth
                dy -= cab.x + cab_depth + board_right
                loc = tM * Vector((dx, dy, dz))
            else:
                # add translation for current cab to border
                loc = tM * Vector((dx + board_right, dy, dz))

    def create_baseboard(self, cab, dz, tM, verts, faces, matids, uvs):

        sx, sy, sz = cab.x, self.thickness, self.base_height + dz + cab.pz
        door_y = self.door_y
        if sz <= 0:
            return

        board_left = cab.board_left
        board_right = cab.board_right
        cab_type = cab.cab_type

        z0 = 0
        z1 = sz

        y0 = -max(sy, self.y + cab.dy - self.base_sink)
        y1 = y0 + sy
        x0 = -board_left
        x1 = sx + board_right
        
        if cab_type == 1:
            # Left corner
            x1 += min(self.base_sink + max(door_y, cab.panel_right_width), self.y - sy)

        elif cab_type == 2:
            # Right corner
            x0 = - (y0 + sy)
            x1 += self.y + cab.dy + max(door_y, cab.panel_left_width)

        elif cab_type in {3, 7}:
            # left board
            f = len(verts)
            x2 = self.base_sink * 0.5 * 2 ** 0.5
            make_box(tM, x2, x0, y0, y1, z0, z1, 0, mat_baseboard, False, verts, faces, matids, uvs)
            
            # right board
            x1 += self.base_sink 
            y0 = board_right + self.y + cab.dy + cab.x
            y1 = y0 - x2
            make_box(tM, x1 + sy, x1, -y0, -y1, z0, z1, 0, mat_baseboard, False, verts, faces, matids, uvs)
            faces.pop(-2)
            faces.pop(-10)
            faces.extend([tuple([f + i for i in v]) for v in [
                (1, 0, 8, 11),
                (5, 1, 11, 15),
                (4, 5, 15, 12),
                (0, 4, 12, 8)
                ]])
            matids.extend([mat_baseboard for i in range(2)])
            uvs.extend([[(0, 0), (1, 0), (1, 1), (0, 1)] for i in range(2)])
            return
            
        # offset sides
        if cab.base_left:
            x0 += cab.base_sink
        if cab.base_right:
            x1 -= cab.base_sink

        # external faces
        make_box(tM, x1, x0, y0, y1, z0, z1, 0, mat_baseboard, False, verts, faces, matids, uvs)

        # left side
        if cab.base_left:
            make_box(tM, x0, x0 + sy, 0, y1, z0, z1, 0, mat_baseboard, False, verts, faces, matids, uvs)

        # right side
        if cab.base_right:
            make_box(tM, x1 - sy, x1, 0, y1, z0, z1, 0, mat_baseboard, False, verts, faces, matids, uvs)

        # Corners
        if 0 < cab_type < 3:
            y1 = -(self.y + cab.dy + door_y)
            # Left
            if cab_type == 1:
                x0 = x1
                y0 += sy

            x1 = x0 + sy
            make_box(tM, x0, x1, y0, y1, z0, z1, 0, mat_baseboard, False, verts, faces, matids, uvs)

    def update_baseboard(self, verts, faces, matids, uvs):
        loc = Vector((0, 0, 0))
        a = 0
        ca = 1
        sa = 0
        door_y = self.door_y

        # accumulate pz for lock mode
        z_accum = 0

        for cab in self.cabinets:
            cab_depth = self.cabinet_depth(cab)
            # side boards size
            board_left = cab.board_left
            board_right = cab.board_right

            if cab.reset_location:
                loc = Vector((0, 0, 0))
                a = 0
                z_accum = 0

            cab_location = cab.location
            cab_type = cab.cab_type

            # rotate R cab
            if cab_type == 2:
                dx = cab_depth + door_y
                a += pi / 2
                loc += Vector((dx * ca, dx * -sa, 0))
            else:

                rot_type = int(cab.rotate)

                if rot_type == RotationType_R90CW:
                    a += pi / 2
                elif rot_type == RotationType_R90CCW:
                    a -= pi / 2
                elif rot_type == RotationType_R180:
                    a += pi
                elif rot_type == RotationType_User:
                    a += cab.angle

            a = a % (2 * pi)

            # add translation from last to current cab
            ca = cos(a)
            sa = sin(a)
            loc += Vector((
                (board_left + cab.px) * ca + cab.py * sa,
                (board_left + cab.px) * -sa + cab.py * ca,
                0))

            # matrix at cabinet axis with z at bottom
            tM = Matrix([
                [ca, sa, 0, loc.x],
                [-sa, ca, 0, loc.y],
                [0, 0, 1, loc.z],
                [0, 0, 0, 1]
                ])

            if cab_location != 2 and cab.baseboard:
                self.create_baseboard(cab, z_accum, tM, verts, faces, matids, uvs)

            if cab.lock_p:
                dx = cab.x
                dy = 0
                dz = 0
                z_accum += cab.pz
            else:
                dx = cab.x - cab.px
                dz = 0
                dy = -cab.py

            if cab_type == 1:
                a += pi / 2
                # add translation for current cab to border
                dx += cab_depth + max(door_y, cab.panel_right_width)
                loc = tM * Vector((dx, dy - cab_depth - door_y, dz))
            elif cab_type == 2:
                dx += cab_depth + board_right + max(door_y, cab.panel_left_width)
                loc = tM * Vector((dx, 0, dz))
            elif cab_type in {3, 7}:
                # Corner 45
                a += pi / 2
                dx += cab_depth
                dy -= cab.x + cab_depth + board_right
                loc = tM * Vector((dx, dy, dz))
            else:
                # add translation for current cab to border
                loc = tM * Vector((dx + board_right, dy, dz))

    def create_counter(self, cab, tM, verts, faces, matids, uvs, start_new, remove_last):
        sx, sy, sz = cab.x, self.y + cab.dy, self.counter_z
        over = self.counter_y
        cab_depth = self.cabinet_depth(cab)
        
        z0 = cab.dz + cab.pz
        z2 = z0 + sz
        z1 = z2 - self.counter_chanfer

        # if corner the size is less
        ts = -cab.board_left
        tx = sx + cab.board_right

        if cab.counter_fill:
            ts -= cab.px

        countertop_hole = cab.countertop_hole
        cab_type = cab.cab_type

        f = len(verts)
        y0 = 0
        y2 = -(sy + over)
        y1 = y2 + self.counter_chanfer

        # first section
        if start_new:
        
            verts.extend([tM * Vector(v) for v in [
                (ts, y0, z0), (ts, y2, z0), (ts, y2, z1), (ts, y1, z2), (ts, y0, z2)
                ]])
            # start face
            faces.extend([tuple([f + i for i in v]) for v in [    
                (0, 1, 2, 3, 4)
                ]])
            matids.append(mat_counter)
        
        else:
            # remove closing face
            faces.pop(-1)
            matids.pop(-1)
            # use last section as first one
            f -= 5
            # remove last section of Left corner
            if remove_last:
                for i in range(5):
                    verts.pop(-1)
                    faces.pop(-1)
                    matids.pop(-1)
                f -= 5
                
        # side faces
        # 45 corners use generate own faces
        if cab_type in {3, 7}:
            # add section when board left > 0
            if cab.board_left > 0:
                ts += cab.board_left
                faces.extend([tuple([f + i for i in v]) for v in [
                    # bottom,      back,        up,           chanfer,      front
                    (0, 4, 9, 5), (4, 3, 8, 9), (3, 2, 7, 8), (2, 1, 6, 7), (1, 0, 5, 6)
                    ]])
                f = len(verts)
                verts.extend([tM * Vector(v) for v in [
                    (ts, y0, z0), (ts, y2, z0), (ts, y2, z1), (ts, y1, z2), (ts, y0, z2)
                    ]])
                
                matids.extend([mat_counter for i in range(5)])
                   
        else:
            # countertop holes generate own faces, except L corner
            if not countertop_hole or cab_type == 1:
                faces.extend([tuple([f + i for i in v]) for v in [
                    # bottom,      back,        up,           chanfer,      front
                    (0, 4, 9, 5), (4, 3, 8, 9), (3, 2, 7, 8), (2, 1, 6, 7), (1, 0, 5, 6)
                    ]])
                matids.extend([mat_counter for i in range(5)])
                
                # close all but Corner
                if cab_type != 1:
                    faces.extend([tuple([f + i for i in v]) for v in [
                        # end side faces
                        (9, 8, 7, 6, 5)
                        ]])
                    matids.append(mat_counter)
    
        # at this point f is first vert of last section
        if countertop_hole:

            # R corner section before hole
            # use current faces
            if cab_type == 2:
                # make 2nd section of faces using corner section as start
                f = len(verts)
                # Corner R
                x0 = -cab.px
                x2 = -y1 - cab.px
                x1 = x2 - self.counter_chanfer
                # add corner section
                verts.extend([tM * Vector(v) for v in [
                    (x0, y0, z0), (x2, y2, z0), (x2, y2, z1), (x1, y1, z2), (x0, y0, z2)
                    ]])
          
            hx = cab.counter_x
            hy = cab.counter_y
            cx = 0.5 * sx
            if cab_type == 2:
                cx += self.y
            cy = 0.5 * sy
            r = 0.02
            tM2 = tM.copy()
            
            # corner 45 rotate 45 deg
            if cab_type in {3, 7}:
                
                sq2 = 0.5 * 2 ** 0.5
                tM2 = tM * Matrix([
                    [sq2, sq2, 0, 0.5 * cab.x],
                    [-sq2, sq2, 0, -(cab_depth + cab.dy) - 0.5 * cab.x],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                    ])
                cx = 0 # cab_depth + cab.x
                cy = -0.5 * cab.x  #(cab_depth + cab.dy) + 0.5 * cab.x
            
            # add verts for hole
            verts.extend([tM2 * Vector(v) for v in chanfer_square(cx, -cy, z0, r, hx, hy)])
            verts.extend([tM2 * Vector(v) for v in chanfer_square(cx, -cy, z2, r, hx, hy)])
            
            if cab_type not in {3, 7}:    
                faces.extend([tuple([f + i for i in v]) for v in [
                    (17, 33, 32, 16), (10, 26, 25, 9), (18, 34, 33, 17),
                    (11, 27, 26, 10), (19, 35, 34, 18), (12, 28, 27, 11),
                    (20, 36, 35, 19), (13, 29, 28, 12), (6, 22, 21, 5),
                    (5, 21, 36, 20), (14, 30, 29, 13), (7, 23, 22, 6),
                    (15, 31, 30, 14), (8, 24, 23, 7), (16, 32, 31, 15),
                    (9, 25, 24, 8),
                    (12, 11, 10, 9, 8, 7, 6, 5, 1, 0),
                    (13, 37, 38, 20, 19, 18, 17, 16, 15, 14),
                    (13, 12, 0, 37), (20, 38, 1, 5), (0, 4, 41, 37),
                    (4, 3, 21, 22, 23, 24, 25, 26, 27, 28),
                    (29, 30, 31, 32, 33, 34, 35, 36, 40, 41),
                    (36, 21, 3, 40),
                    (29, 41, 4, 28), (3, 2, 39, 40), (2, 1, 38, 39),
                    (41, 40, 39, 38, 37)
                    ]])

                matids.extend([mat_counter for i in range(28)])

                uvs.extend([
                    [(0.016, 0.962), (0.016, 0.999), (0.344, 0.999), (0.344, 0.962)],
                    [(0.353, 0.962), (0.353, 0.999), (0.344, 0.999), (0.344, 0.962)],
                    [(0.007, 0.962), (0.007, 0.999), (0.016, 0.999), (0.016, 0.962)],
                    [(0.508, 0.962), (0.508, 0.999), (0.501, 0.999), (0.501, 0.962)],
                    [(0.945, 0.962), (0.945, 0.999), (0.952, 0.999), (0.952, 0.962)],
                    [(0.517, 0.962), (0.517, 0.999), (0.508, 0.999), (0.508, 0.962)],
                    [(0.936, 0.962), (0.936, 0.999), (0.945, 0.999), (0.945, 0.962)],
                    [(0.936, 0.962), (0.936, 0.999), (0.517, 0.999), (0.517, 0.962)],
                    [(0.508, 0.962), (0.508, 0.999), (0.517, 0.999), (0.517, 0.962)],
                    [(0.517, 0.962), (0.517, 0.999), (0.936, 0.999), (0.936, 0.962)],
                    [(0.945, 0.962), (0.945, 0.999), (0.936, 0.999), (0.936, 0.962)],
                    [(0.007, 0.962), (0.007, 0.999), (0.0, 0.999), (0.0, 0.962)],
                    [(0.952, 0.962), (0.952, 0.999), (0.945, 0.999), (0.945, 0.962)],
                    [(0.016, 0.962), (0.016, 0.999), (0.007, 0.999), (0.007, 0.962)],
                    [(0.344, 0.962), (0.344, 0.999), (0.353, 0.999), (0.353, 0.962)],
                    [(0.344, 0.962), (0.344, 0.999), (0.016, 0.999), (0.016, 0.962)],
                    [(0.453, 0.518), (0.517, 0.47), (0.508, 0.469), (0.501, 0.465), (0.499, 0.461),
                    (0.499, 0.287), (0.501, 0.283), (0.508, 0.279), (0.517, 0.278), (0.453, 0.22)],
                    [(0.936, 0.47), (1.0, 0.518), (1.0, 0.22), (0.936, 0.278), (0.945, 0.279),
                    (0.952, 0.283), (0.954, 0.287), (0.954, 0.461), (0.952, 0.465), (0.945, 0.469)],
                    [(0.936, 0.47), (0.517, 0.47), (0.453, 0.518), (1.0, 0.518)],
                    [(0.936, 0.278), (1.0, 0.22), (0.453, 0.22), (0.517, 0.278)],
                    [(0.453, 0.962), (0.453, 1.0), (1.0, 1.0), (1.0, 0.962)],
                    [(0.453, 0.518), (0.453, 0.221), (0.517, 0.278), (0.508, 0.279), (0.501, 0.283),
                    (0.499, 0.287), (0.499, 0.461), (0.501, 0.465), (0.508, 0.469), (0.517, 0.47)],
                    [(0.936, 0.47), (0.945, 0.469), (0.952, 0.465), (0.954, 0.461), (0.954, 0.287),
                    (0.952, 0.283), (0.945, 0.279), (0.936, 0.278), (1.0, 0.221), (1.0, 0.518)],
                    [(0.936, 0.278), (0.517, 0.278), (0.453, 0.221), (1.0, 0.221)],
                    [(0.936, 0.47), (1.0, 0.518), (0.453, 0.518), (0.517, 0.47)],
                    [(0.453, 0.038), (0.453, 0.037), (1.0, 0.037), (1.0, 0.038)],
                    [(0.453, 0.037), (0.453, 0.0), (1.0, 0.0), (1.0, 0.037)]
                    ])
        
        # Corner edges
        # corner section faces and verts
        if 0 < cab_type < 3:
                
            # f = len(verts)

            door_y = self.door_y

            if cab_type == 1:
                # Corner L
                x0 = sx + max(door_y, cab.panel_right_width) + self.y
                x2 = sx + max(door_y, cab.panel_right_width) - over
                x1 = x2 + self.counter_chanfer

            elif cab_type == 2:
                # Corner R
                x0 = -cab.px
                x2 = -y1 - cab.px
                x1 = x2 - self.counter_chanfer

            # add corner section after hole when type = L
            if cab_type == 1 or not countertop_hole:
                f = len(verts)
                verts.extend([tM * Vector(v) for v in [
                    (x0, y0, z0), (x2, y2, z0), (x2, y2, z1), (x1, y1, z2), (x0, y0, z2)
                    ]])

            if cab_type == 1:
                # Corner L
                y0 = -(self.y + max(door_y, cab.panel_right_width))
                y1 = y0
                y2 = y0
                
            elif cab_type == 2:
                # Corner R
                x0 = sx + self.y + cab.board_right + max(door_y, cab.panel_left_width)
                x1 = x0
                x2 = x0
                y0 = 0
                y2 = -(sy + over)
                y1 = y2 + self.counter_chanfer
            
            # add ending section
            verts.extend([tM * Vector(v) for v in [
                (x0, y0, z0), (x2, y2, z0), (x2, y2, z1), (x1, y1, z2), (x0, y0, z2)
                ]])

            if cab_type == 1 or not countertop_hole:
                # add faces section after hole when type = L
                faces.extend([tuple([f + i for i in v]) for v in [
                    (0, 4, 9, 5), (4, 3, 8, 9), (3, 2, 7, 8), (2, 1, 6, 7), (1, 0, 5, 6),
                    (9, 8, 7, 6, 5)
                    ]])
                matids.extend([mat_counter for i in range(6)])
        
        # add corner verts and faces (all but first one)
        elif cab_type in {3, 7}:
            # Corner 45
            x0 = cab.x + cab_depth - cab.px
            x2 = cab.x - over
            x1 = x2 + self.counter_chanfer
            y1 = - cab.x - cab_depth
            verts.extend([tM * Vector(v) for v in [
                (x0, 0, z0), (x0, 0, z2),
                (x0, y1, z0), (x2, y1, z0), (x2, y1, z1), (x1, y1, z2), (x0, y1, z2)
                ]])
            if countertop_hole:
                matids.extend([mat_counter for i in range(29)])
                faces.extend([tuple([f + i for i in v]) for v in [
                    (17, 33, 32, 16), (10, 26, 25, 9),
                    (18, 34, 33, 17), (11, 27, 26, 10), (19, 35, 34, 18),
                    (12, 28, 27, 11), (20, 36, 35, 19), (13, 29, 28, 12),
                    (6, 22, 21, 5), (5, 21, 36, 20), (14, 30, 29, 13),
                    (7, 23, 22, 6), (15, 31, 30, 14), (8, 24, 23, 7),
                    (16, 32, 31, 15), (9, 25, 24, 8), (12, 11, 10, 9, 8, 7, 6, 5, 1, 0),
                    (4, 3, 21, 22, 23, 24, 25, 26, 27, 28), (0, 4, 38, 37),
                    (37, 38, 43, 39), (2, 1, 40, 41), (3, 2, 41, 42),
                    (36, 21, 3, 42), (20, 40, 1, 5), (32, 33, 34, 35, 36, 42, 43, 29, 30, 31),
                    (29, 43, 38, 4, 28), (13, 12, 0, 37, 39), (17, 16, 15, 14, 13, 39, 40, 20, 19, 18),
                    (43, 42, 41, 40, 39)
                    ]])
                uvs.extend([
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.5, 1.0), (0.794, 0.905), (0.976, 0.655), (0.976, 0.345), (0.794, 0.095), 
                    (0.5, 0.0), (0.206, 0.095), (0.024, 0.345), (0.024, 0.655), (0.206, 0.905)],
                    [(0.5, 1.0), (0.794, 0.905), (0.976, 0.655), (0.976, 0.345), (0.794, 0.095), 
                    (0.5, 0.0), (0.206, 0.095), (0.024, 0.345), (0.024, 0.655), (0.206, 0.905)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.5, 1.0), (0.794, 0.905), (0.976, 0.655), (0.976, 0.345), (0.794, 0.095), 
                    (0.5, 0.0), (0.206, 0.095), (0.024, 0.345), (0.024, 0.655), (0.206, 0.905)],
                    [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)],
                    [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)],
                    [(0.5, 1.0), (0.794, 0.905), (0.976, 0.655), (0.976, 0.345), (0.794, 0.095), 
                    (0.5, 0.0), (0.206, 0.095), (0.024, 0.345), (0.024, 0.655), (0.206, 0.905)],
                    [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)],
                    ])
            else:
                faces.extend([tuple([f + i for i in v]) for v in [
                    (1, 0, 5, 7, 8), (3, 10, 11, 6, 4),
                    (0, 4, 6, 5), (5, 6, 11, 7), (2, 1, 8, 9),
                    (3, 2, 9, 10), (11, 10, 9, 8, 7)
                    ]])
                matids.extend([mat_counter for i in range(7)])   
                uvs.extend([    
                    [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)],
                    [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],
                    [(0.5, 1.0), (0.976, 0.655), (0.794, 0.095), (0.206, 0.095), (0.024, 0.655)]
                    ])
            # add section when board left > 0
            if cab.board_right > 0:
                    faces.pop(-1)
                    y1 -= cab.board_right
                    f = len(verts) - 5
                    verts.extend([tM * Vector(v) for v in [
                        (x0, y1, z0), (x2, y1, z0), (x2, y1, z1), (x1, y1, z2), (x0, y1, z2)
                        ]])
                    faces.extend([tuple([f + i for i in v]) for v in [
                        # bottom,      back,        up,           chanfer,      front
                        (0, 4, 9, 5), (4, 3, 8, 9), (3, 2, 7, 8), (2, 1, 6, 7), (1, 0, 5, 6),
                        (9, 8, 7, 6, 5)
                        ]])
                        
                    matids.extend([mat_counter for i in range(5)])    
                           
        else:
            # add last section verts
            verts.extend([tM * Vector(v) for v in [
                (tx, y0, z0), (tx, y2, z0), (tx, y2, z1), (tx, y1, z2), (tx, y0, z2)
                ]])
        
    def update_counter(self, verts, faces, matids, uvs):
        loc = Vector((0, 0, 0))
        a = 0
        ca = 1
        sa = 0
        z = self.height_default
        door_y = self.door_y
        start_new = True
        remove_last = False
        
        last_dy = 0
        last_dz = 0
        last_px = 0
        last_py = 0
        last_pz = 0

        if self.baseboard:
            z += self.base_height
        
        for cab in self.cabinets:

            cab_depth = self.cabinet_depth(cab)
            # side boards size
            board_left = cab.board_left
            board_right = cab.board_right
            
            if cab.reset_location:
                loc = Vector((0, 0, 0))
                a = 0

            cab_type = cab.cab_type
            cab_location = cab.location

            # rotate R cab
            if cab_type == 2:
                dx = cab_depth + door_y
                a += pi / 2
                loc += Vector((dx * ca, dx * -sa, 0))
            else:

                rot_type = int(cab.rotate)

                if rot_type == RotationType_R90CW:
                    a += pi / 2
                elif rot_type == RotationType_R90CCW:
                    a -= pi / 2
                elif rot_type == RotationType_R180:
                    a += pi
                elif rot_type == RotationType_User:
                    a += cab.angle

            a = a % (2 * pi)

            # add translation from last to current cab
            ca = cos(a)
            sa = sin(a)
            loc += Vector((
                (board_left + cab.px) * ca + cab.py * sa,
                (board_left + cab.px) * -sa + cab.py * ca,
                z))

            # matrix at cabinet axis with z at bottom
            tM = Matrix([
                [ca, sa, 0, loc.x],
                [-sa, ca, 0, loc.y],
                [0, 0, 1, loc.z],
                [0, 0, 0, 1]
                ])

            if (last_py != cab.py or
                    last_pz != cab.pz or
                    (last_px != cab.px and not cab.counter_fill) or
                    last_dy != cab.dy or
                    last_dz != cab.dz or
                    cab_location != 1 or
                    cab.counter == "0" or
                    cab.reset_location or
                    cab.rotate != "0"):
                remove_last = False    
                start_new = True

            last_px = cab.px
            last_py = cab.py
            last_pz = cab.pz
            last_dy = cab.dy
            last_dz = cab.dz

            if cab_location == 1 and cab.counter != "0":
                self.create_counter(cab, tM, verts, faces, matids, uvs, start_new, remove_last)
                start_new = False
                # remove last section of L Corner
                remove_last = cab_type == 1    

            if cab.lock_p:
                dx = cab.x
                dy = 0
                dz = cab.pz - z
            else:
                dx = cab.x - cab.px
                dz = -z
                dy = -cab.py

            if cab_type == 1:
                a += pi / 2
                # add translation for current cab to border
                dx += cab_depth + max(door_y, cab.panel_right_width)
                loc = tM * Vector((dx, dy - cab_depth - door_y, dz))
            elif cab_type == 2:
                dx += cab_depth + board_right + max(door_y, cab.panel_left_width)
                loc = tM * Vector((dx, 0, dz))
            elif cab_type in {3, 7}:
                # Corner 45
                a += pi / 2
                dx += cab_depth
                dy -= cab.x + cab_depth + board_right
                loc = tM * Vector((dx, dy, dz))
            else:
                # add translation for current cab to border
                loc = tM * Vector((dx + board_right, dy, dz))

    def get_childs_modules(self, o):
        return [child for child in o.children if archipack_kitchen_module.filter(child)]

    def remove_modules(self, context, childs, to_remove):
        for child in childs:
            if to_remove < 1:
                return
            to_remove -= 1
            context.scene.objects.unlink(child)
            bpy.data.objects.remove(child, do_unlink=True)

    def update_modules(self, context, o):

        # real childs
        childs = self.get_childs_modules(o)

        # wanted childs
        w_childs = 0
        for cab in self.cabinets:

            z0 = 0
            zmax = self.cabinet_height(cab)

            cab.update_parts()

            for module in cab.modules:

                n_panels = module.n_panels

                # Door height
                if module.modules == 0 or self.z_mode == '2':
                    # user defined height / absolute z mode
                    zd = module.z
                else:
                    zd = self.module_size * module.modules

                zd = min(zd, zmax - z0)
                if zd == 0:
                    continue
                    
                # range hood, no door   
                if module.type == '55':
                    n_panels = 0
                
                # No door, accumulate spacing
                w_childs += n_panels
                z0 += zd

        # real childs
        n_childs = len(childs)

        # remove child
        if n_childs > w_childs:
            self.remove_modules(context, childs, n_childs - w_childs)

        if w_childs == 0:
            return

        childs = self.get_childs_modules(o)
        n_childs = len(childs)

        loc = Vector((0, 0, 0))
        tM = Matrix()
        a = 0
        panel = 0
        ca = 1
        sa = 0
        door_y = self.door_y

        for cab in self.cabinets:
            
            cab_depth = self.cabinet_depth(cab)
        
            # side boards size
            board_left = cab.board_left
            board_right = cab.board_right
            cab_type = cab.cab_type
            cab_location = cab.location

            z = cab.pz

            if self.baseboard:
                z += self.base_height
            
            sx = cab.x
            sy = cab_depth + cab.dy + door_y
            dx = 0
            
            # Wall
            if cab_location == 2:
                z += self.altitude_wall - cab.dz
                # adjust corner size to fit bottom ones
                if cab_type == 1:
                    sx += self.y - cab_depth
                elif cab_type == 2:
                    sx += self.y - cab_depth
                    
            if cab.reset_location:
                loc = Vector((0, 0, 0))
                a = 0

            if cab_type == 2:
                # rotate R cab
                board_left = max(door_y, cab.panel_left_width) - door_y
                dx = cab_depth + door_y
                a += pi / 2
                loc += Vector((dx * ca, dx * -sa, 0))
             
            else:

                rot_type = int(cab.rotate)

                if rot_type == RotationType_R90CW:
                    a += pi / 2
                elif rot_type == RotationType_R90CCW:
                    a -= pi / 2
                elif rot_type == RotationType_R180:
                    a += pi
                elif rot_type == RotationType_User:
                    a += cab.angle

            a = a % (2 * pi)

            # add translation from last to current cab
            ca = cos(a)
            sa = sin(a)
            loc += Vector((
                (board_left + cab.px) * ca + cab.py * sa,
                (board_left + cab.px) * -sa + cab.py * ca,
                0))
            # matrix at cabinet axis with z at bottom
            tM = Matrix([
                [ca, sa, 0, loc.x],
                [-sa, ca, 0, loc.y],
                [0, 0, 1, loc.z],
                [0, 0, 0, 1]
                ])
           
                    
            # corner 45 relocate doors
            if cab_type in {3, 7}: 
                tM2 = tM.copy()
                a += pi / 4
                ca = cos(a)
                sa = sin(a)
                x = 0.5 * (cab_depth + cab.dy + door_y) * (2 ** 0.5)
                y = cab_depth + cab.dy + door_y - x
                
                loc += Vector((
                    x * ca + y * sa, 
                    x * -sa + y * ca, 
                    0))
                sx = (cab.x - door_y) * (2 ** 0.5)   
                tM = Matrix([
                    [ca, sa, 0, loc.x],
                    [-sa, ca, 0, loc.y],
                    [0, 0, 1, loc.z],
                    [0, 0, 0, 1]
                    ])

            z0 = 0
            zmax = self.cabinet_height(cab)

            for module in cab.modules:

                n_panels = module.n_panels

                pivot = 1
                if module.type in {'2', '12'}:
                    pivot = -1

                # Door height
                if module.modules == 0 or self.z_mode == '2':
                    # user defined height / absolute z mode
                    zd = module.z
                else:
                    zd = self.module_size * module.modules

                zd = min(zd, zmax - z0)
                if zd == 0:
                    continue

                # No door, accumulate spacing
                if n_panels == 0:
                    z0 += zd
                    continue
                
                # range hood
                # No door, accumulate spacing
                if module.type == '55':
                    z0 += zd
                    continue
                
                size = Vector((sx / n_panels, zd, door_y))

                # handle on top or bottom of door panel
                # choose location nearest half height
                handle_location = 0
                altitude_ref = 0.5 * self.height_full - (z + z0)
                dist = abs(altitude_ref)
                if abs(altitude_ref - 0.5 * zd) < dist:
                    handle_location = 0.5
                if abs(altitude_ref - zd) < dist:
                    handle_location = 1

                for i in range(n_panels):

                    if i > 0:
                        pivot = -pivot

                    if panel >= n_childs:
                        name = 'Cabinet door'
                        # Create a panel mesh
                        m = bpy.data.meshes.new(name)
                        child = bpy.data.objects.new(name, m)
                        props = m.archipack_kitchen_module.add()
                        context.scene.objects.link(child)
                        child.select = True
                        context.scene.objects.active = child
                        m = child.archipack_material.add()
                        m.category = "kitchen"
                        m.material = o.archipack_material[0].material
                        child.lock_location = (False, False, True)
                        child.lock_rotation = (False, True, False)
                        child.lock_scale = (True, True, True)
                        child.show_transparent = True
                        # parenting at 0, 0, 0 before set object matrix_world
                        # so location remains local from frame
                        child.parent = o
                        child.matrix_world = o.matrix_world.copy()

                    else:
                        child = childs[panel]
                        child.select = True
                        context.scene.objects.active = child
                        props = archipack_kitchen_module.datablock(child)

                    if props is not None:
                        props.update(context, size, pivot, self, cab, module, handle_location)

                    # location y + frame width.
                    child.location = tM * Vector((
                        dx + 0.5 * (1 - pivot) * sx,
                        -sy,
                        z + z0))

                    child.rotation_euler.z = -a
                    panel += 1

                z0 += zd

            if cab.lock_p:
                dx = cab.x
                dy = 0
                dz = cab.pz
            else:
                dx = cab.x - cab.px
                dz = 0
                dy = -cab.py

            if cab_type == 1:
                a += pi / 2
                # add translation for current cab to border
                dx += self.y + max(door_y, cab.panel_right_width)
                loc = tM * Vector((dx, dy - cab_depth - door_y, dz))
            elif cab_type == 2:
                dx += self.y + board_right + door_y
                loc = tM * Vector((dx, 0, dz))
            elif cab_type in {3, 7}:
                # Corner 45
                a += pi / 4
                dx += cab_depth
                dy -= cab.x + cab_depth + board_right
                loc = tM2 * Vector((dx, dy, dz))
            else:
                # add translation for current cab to border
                loc = tM * Vector((dx + board_right, dy, dz))

    def setup_manipulators(self):

        for i in range(self.cabinet_num):
            p = self.cabinets[i]
            n_manips = len(p.manipulators)
            if n_manips < 1:
                s = p.manipulators.add()
                s.type_key = 'DUMB_STRING'
            p.manipulators[0].prop1_name = str(i + 1)

    def manipulable_setup(self, context):
        """
            NOTE:
            this one assume context.active_object is the instance this
            data belongs to, failing to do so will result in wrong
            manipulators set on active object
        """
        self.manipulable_disable(context)

        o = context.active_object

        self.setup_manipulators()

        for i, part in enumerate(self.cabinets):
            self.manip_stack.append(part.manipulators[0].setup(context, o, part))

    def manipulable_invoke(self, context):
        """
            call this in operator invoke()
        """
        # print("manipulable_invoke")
        if self.manipulate_mode:
            self.manipulable_disable(context)
            return False

        self.manipulable_setup(context)
        self.manipulate_mode = True

        self._manipulable_invoke(context)

        return True

    def update_parts(self):

        # remove cabinets
        for i in range(len(self.cabinets), self.cabinet_num, -1):
            self.cabinets.remove(i - 1)

        # add cabinets
        for i in range(len(self.cabinets), self.cabinet_num):
            self.cabinets.add()

        self.setup_manipulators()

    def update(self, context, manipulable_refresh=False):
        # support for "copy to selected"
        o = self.find_in_selection(context, self.auto_update)

        if o is None:
            return

        if manipulable_refresh:
            self.manipulable_disable(context)

        self.update_parts()

        verts = []
        faces = []
        matids = []
        uvs = []

        if self.counter:
            self.update_counter(verts, faces, matids, uvs)

        self.update_cabinets(context, verts, faces, matids, uvs)

        if self.baseboard:
            self.update_baseboard(verts, faces, matids, uvs)

        bmed.buildmesh(context, o, verts, faces, matids)
        # 
        self.update_modules(context, o)

        if manipulable_refresh:
            self.manipulable_refresh = True

        """
        # setup 3d points for gl manipulators
        x, y = 0.5 * self.x, 0.5 * self.y
        self.manipulators[0].set_pts([(-x, -y, 0), (x, -y, 0), (1, 0, 0)])
        self.manipulators[1].set_pts([(-x, -y, 0), (-x, y, 0), (-1, 0, 0)])
        self.manipulators[2].set_pts([(x, -y, 0), (x, -y, self.z), (-1, 0, 0)])
        """
        # restore context
        self.restore_context(context)


class ARCHIPACK_PT_kitchen(Panel):
    bl_idname = "ARCHIPACK_PT_kitchen"
    bl_label = "Kitchen"
    bl_description = "Cabinet Generator"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    # bl_context = 'object'
    bl_category = 'ArchiPack'

    @classmethod
    def poll(cls, context):
        return archipack_kitchen.filter(context.active_object)

    def draw(self, context):
        o = context.active_object
        prop = archipack_kitchen.datablock(o)

        if prop is None:
            return

        layout = self.layout
        layout.operator('archipack.kitchen_manipulate', icon='HAND')
        """
        row = layout.row(align=True)
        row.operator('archipack.kitchen', text="Refresh", icon='FILE_REFRESH').mode = 'REFRESH'
        if o.data.users > 1:
            row.operator('archipack.kitchen', text="Make unique", icon='UNLINKED').mode = 'UNIQUE'
        """
        layout.operator('archipack.kitchen', text="Delete", icon='ERROR').mode = 'DELETE'
        box = layout.box()
        row = box.row(align=True)
        row.operator("archipack.kitchen_preset_menu", text=bpy.types.ARCHIPACK_OT_kitchen_preset_menu.bl_label)
        row.operator("archipack.kitchen_preset", text="", icon='ZOOMIN')
        row.operator("archipack.kitchen_preset", text="", icon='ZOOMOUT').remove_active = True

        box = layout.box()
        if prop.expand:
            box.prop(prop, "expand", icon="TRIA_DOWN", icon_only=True, text="Kitchen", emboss=False)

            row = box.row()
            row.prop(prop, 'z_mode', text="")
            if prop.z_mode == '1':
                row.prop(prop, 'module_size')
                row = box.row()
                row.prop(prop, 'modules_default')
                row.prop(prop, 'y')
                row = box.row()
                row.prop(prop, 'modules_wall')
                row.prop(prop, 'yw')
                box.prop(prop, 'modules_full')
            else:
                row = box.row()
                row.prop(prop, 'z_default')
                row.prop(prop, 'y')
                row = box.row()
                row.prop(prop, 'z_wall')
                row.prop(prop, 'yw')
                box.prop(prop, 'z_full')

            row = box.row()
            row.prop(prop, 'thickness')

            box = layout.box()
            box.prop(prop, 'door_style')
            row = box.row()
            row.prop(prop, 'door_y')
            if int(prop.door_style) > 1:
                row.prop(prop, 'door_x')
            row.prop(prop, 'door_chanfer')

            box.prop(prop, 'handle', text="Handle")
            if prop.handle != "9":
                row = box.row()
                row.prop(prop, 'handle_x')
                row.prop(prop, 'handle_z')
                row.prop(prop, 'handle_scale')
            box = layout.box()
            box.prop(prop, "counter")
            if prop.counter:
                row = box.row()
                row.prop(prop, "counter_z")
                row.prop(prop, "counter_y")
                row.prop(prop, "counter_chanfer")
            box.prop(prop, 'baseboard')
            if prop.baseboard:
                row = box.row()
                row.prop(prop, 'base_height')
                row.prop(prop, 'base_sink')

            box = layout.box()
            row = box.row()

        else:
            row = box.row()
            row.prop(prop, "expand", icon="TRIA_RIGHT", icon_only=True, text="Kitchen", emboss=False)

        # Cabinet number
        row.prop(prop, 'cabinet_num')
        # Add menu for cabinets
        for i, cab in enumerate(prop.cabinets):
            box = layout.box()
            cab.draw(box, i, prop)


class ARCHIPACK_PT_kitchen_module(Panel):
    bl_idname = "ARCHIPACK_PT_kitchen_module"
    bl_label = "Kitchen module"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'ArchiPack'

    @classmethod
    def poll(cls, context):
        return archipack_kitchen_module.filter(context.active_object)

    def draw(self, context):
        layout = self.layout
        layout.operator("archipack.select_parent")


# ------------------------------------------------------------------
# Define operator class to create object
# ------------------------------------------------------------------


class ARCHIPACK_OT_kitchen(ArchipackCreateTool, Operator):
    bl_idname = "archipack.kitchen"
    bl_label = "Kitchen"
    bl_description = "Kitchen"
    bl_category = 'Archipack'
    bl_options = {'REGISTER', 'UNDO'}

    thickness = FloatProperty(
            name='Thickness', min=0.001, default=0.018, precision=3,
            description='Board thickness',
            )
    y = FloatProperty(
            name='Depth', min=0.001, default=0.59, precision=3,
            description='Default cabinet depth',
            )
    z = FloatProperty(
            name='Height', min=0.001, default=0.70, precision=3,
            description='Default cabinet height',
            )
    mode = EnumProperty(
            items=(
            ('CREATE', 'Create', '', 0),
            ('DELETE', 'Delete', '', 1),
            ('REFRESH', 'Refresh', '', 2),
            ('UNIQUE', 'Make unique', '', 3),
            ),
            default='CREATE'
            )

    def draw(self, context):
        layout = self.layout
        row = layout.row()
        row.label("Use Properties panel (N) to define parms", icon='INFO')

    def delete(self, context):
        o = context.active_object
        if archipack_kitchen.filter(o):
            bpy.ops.archipack.disable_manipulate()
            for child in o.children:
                context.scene.objects.unlink(child)
                bpy.data.objects.remove(child, do_unlink=True)
            context.scene.objects.unlink(o)
            bpy.data.objects.remove(o, do_unlink=True)
    
    def create(self, context):
        m = bpy.data.meshes.new("Kitchen")
        o = bpy.data.objects.new("Kitchen", m)
        d = m.archipack_kitchen.add()
        d.thickness = self.thickness
        d.y = self.y
        d.z = self.z
        context.scene.objects.link(o)
        o.select = True
        context.scene.objects.active = o
        self.add_material(o)
        self.load_preset(d)
        # select frame
        o.select = True
        context.scene.objects.active = o
        return o

    # -----------------------------------------------------
    # Execute
    # -----------------------------------------------------
    def execute(self, context):
        if context.mode == "OBJECT":
            bpy.ops.object.select_all(action="DESELECT")
            if self.mode == 'CREATE':
                o = self.create(context)
                o.location = bpy.context.scene.cursor_location
                o.select = True
                context.scene.objects.active = o
                self.manipulate()
            else:
                self.delete(context)
            return {'FINISHED'}
        else:
            self.report({'WARNING'}, "Archipack: Option only valid in Object mode")
            return {'CANCELLED'}


# ------------------------------------------------------------------
# Define operator class to add / remove parts
# ------------------------------------------------------------------


class ARCHIPACK_OT_kitchen_insert(Operator):
    bl_idname = "archipack.kitchen_insert"
    bl_label = "Insert"
    bl_description = "Insert part"
    bl_category = 'Archipack'
    bl_options = {'REGISTER', 'UNDO'}
    index = IntProperty(default=0)

    def execute(self, context):
        if context.mode == "OBJECT":
            d = archipack_kitchen.datablock(context.active_object)
            if d is None:
                return {'CANCELLED'}
            d.insert_part(context, self.index)
            return {'FINISHED'}
        else:
            self.report({'WARNING'}, "Archipack: Option only valid in Object mode")
            return {'CANCELLED'}


class ARCHIPACK_OT_kitchen_remove(Operator):
    bl_idname = "archipack.kitchen_remove"
    bl_label = "Remove"
    bl_description = "Remove part"
    bl_category = 'Archipack'
    bl_options = {'REGISTER', 'UNDO'}
    index = IntProperty(default=0)

    def execute(self, context):
        if context.mode == "OBJECT":
            d = archipack_kitchen.datablock(context.active_object)
            if d is None:
                return {'CANCELLED'}
            d.remove_part(context, self.index)
            return {'FINISHED'}
        else:
            self.report({'WARNING'}, "Archipack: Option only valid in Object mode")
            return {'CANCELLED'}


# ------------------------------------------------------------------
# Define operator class to manipulate object
# ------------------------------------------------------------------


class ARCHIPACK_OT_kitchen_manipulate(Operator):
    bl_idname = "archipack.kitchen_manipulate"
    bl_label = "Manipulate"
    bl_description = "Manipulate"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(self, context):
        return archipack_kitchen.filter(context.active_object)

    def invoke(self, context, event):
        d = archipack_kitchen.datablock(context.active_object)
        d.manipulable_invoke(context)
        return {'FINISHED'}


# ------------------------------------------------------------------
# Define operator class to load / save presets
# ------------------------------------------------------------------


class ARCHIPACK_OT_kitchen_preset_menu(PresetMenuOperator, Operator):
    bl_description = "Show Kitchen Presets"
    bl_idname = "archipack.kitchen_preset_menu"
    bl_label = "Kitchen Presets"
    preset_subdir = "archipack_kitchen"


class ARCHIPACK_OT_kitchen_preset(ArchipackPreset, Operator):
    """Add a Kitchen Preset"""
    bl_idname = "archipack.kitchen_preset"
    bl_label = "Add Kitchen Preset"
    preset_menu = "ARCHIPACK_OT_kitchen_preset_menu"

    @property
    def blacklist(self):
        # 'x', 'y', 'z', 'altitude', 'kitchen_shape'
        return ['manipulators']


def register():
    bpy.utils.register_class(archipack_kitchen_module)
    Mesh.archipack_kitchen_module = CollectionProperty(type=archipack_kitchen_module)
    bpy.utils.register_class(ARCHIPACK_PT_kitchen_module)
    bpy.utils.register_class(archipack_kitchen_cabinet)
    bpy.utils.register_class(archipack_kitchen)
    Mesh.archipack_kitchen = CollectionProperty(type=archipack_kitchen)
    bpy.utils.register_class(ARCHIPACK_OT_kitchen_preset_menu)
    bpy.utils.register_class(ARCHIPACK_PT_kitchen)
    bpy.utils.register_class(ARCHIPACK_OT_kitchen)
    bpy.utils.register_class(ARCHIPACK_OT_kitchen_remove)
    bpy.utils.register_class(ARCHIPACK_OT_kitchen_insert)
    bpy.utils.register_class(ARCHIPACK_OT_kitchen_preset)
    bpy.utils.register_class(ARCHIPACK_OT_kitchen_manipulate)


def unregister():
    bpy.utils.unregister_class(archipack_kitchen_cabinet)
    bpy.utils.unregister_class(archipack_kitchen_module)
    bpy.utils.unregister_class(ARCHIPACK_PT_kitchen_module)
    del Mesh.archipack_kitchen_module
    bpy.utils.unregister_class(archipack_kitchen)
    del Mesh.archipack_kitchen
    bpy.utils.unregister_class(ARCHIPACK_OT_kitchen_preset_menu)
    bpy.utils.unregister_class(ARCHIPACK_PT_kitchen)
    bpy.utils.unregister_class(ARCHIPACK_OT_kitchen)
    bpy.utils.unregister_class(ARCHIPACK_OT_kitchen_remove)
    bpy.utils.unregister_class(ARCHIPACK_OT_kitchen_insert)
    bpy.utils.unregister_class(ARCHIPACK_OT_kitchen_preset)
    bpy.utils.unregister_class(ARCHIPACK_OT_kitchen_manipulate)
